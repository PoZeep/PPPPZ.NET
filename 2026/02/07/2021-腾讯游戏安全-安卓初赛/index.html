<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>2021 腾讯游戏安全 安卓初赛 - P.Z&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
    
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
 
  

    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>

<meta name="generator" content="Hexo 6.0.0"></head>

<!-- //unpkg.com/@waline/client -->
<!--  -->
    <body data-color-scheme="auto">
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">P.Z&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/Friends/Friends">Friends</a>
            
            
            
            <a class="nav-item" href="/About/About">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/PoZeep" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://space.bilibili.com/39892350" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            <span>February</span>
            
            
            
            
            
            
            
            
            
            
            
            <span>7,</span>
            <span>2026</span>
        </div>
        

        <h2 class="title">2021 腾讯游戏安全 安卓初赛</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h1 id="2021-腾讯游戏安全-安卓初赛"><a href="#2021-腾讯游戏安全-安卓初赛" class="headerlink" title="2021 腾讯游戏安全 安卓初赛"></a>2021 腾讯游戏安全 安卓初赛</h1><blockquote>
<p>本题难度适中，非常适合入门复现。<br>目标实现无敌版鼠鼠，效果图：<img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260207124901314.png" alt="img"></p>
</blockquote>
<hr>
<h2 id="0x00-识别架构"><a href="#0x00-识别架构" class="headerlink" title="0x00 识别架构"></a>0x00 识别架构</h2><p>Unity 逆向，Mono 打包的 apk，找到 Assembly-CSharp.dll，确定为 Mono 类的逆向，关键的业务代码也就在这个 dll 里，然而一看发现不对劲，拉一个正常的对比。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205121247308.png" alt="img"></p>
<p>既然是加密了，动态肯定会解密，于是就是了解一下 Unity 其 Mono 打包成 apk 的加载流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ 安卓系统 (Android OS) ]</span><br><span class="line">       ↓</span><br><span class="line">[ Unity 引擎层 (libunity.so) ]</span><br><span class="line">       ↓</span><br><span class="line">[ Mono 虚拟机层 (libmono.so) ] &lt;--- 你可以 Hook 这里</span><br><span class="line">       ↓</span><br><span class="line">[ 托管代码层 (Assembly-CSharp.dll) ] &lt;--- 你可以直接反编译这里</span><br><span class="line">       ↓</span><br><span class="line">[ JIT 编译器 ] -&gt; [ 生成内存中的 ARM 指令 ] -&gt; [ CPU 执行 ]</span><br></pre></td></tr></table></figure>

<ul>
<li>libunity.so 是 Unity 的核心引擎库</li>
<li>libmono.so 是 Mono 的虚拟机核心</li>
<li>libmono.so 激活后就会去找基础库 mscorlib.dll 和业务代码 Assembly-CSharp.dll</li>
</ul>
<hr>
<h2 id="0x01-字符串混淆处理"><a href="#0x01-字符串混淆处理" class="headerlink" title="0x01 字符串混淆处理"></a>0x01 字符串混淆处理</h2><p>于是去查看 libmono.so 哪里动了手脚，尝试通过 frida hook mono_image_open_from_data_with_name，因为该函数是加载 Assembly-Csharp.dll 的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libbase = Module.findBaseAddress(<span class="string">&quot;libmono.so&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;libbase&quot;</span>, libbase);  </span><br><span class="line"><span class="keyword">var</span> addr = Module.findExportByName(<span class="string">&quot;libmono.so&quot;</span>, <span class="string">&quot;mono_image_open_from_data_with_name&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;mono_image_open_from_data_with_name&quot;</span>, addr);  </span><br></pre></td></tr></table></figure>

<p>但是有frida检测，似乎无法直接到达加载该dll的时机，所以现在去解决frida检测。</p>
<p>先看了 init_array 看看反调试是不是写这了，然后发现 0x1F120 的函数，显然是动态解密一些数据的函数，不管是调试还是模拟执行都行，不过通过 LLM 辅助解析，写个 idapython 脚本，该函数就是传一个常量，返回解密后的数据到 bss 数据段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">============================================================</span><br><span class="line">doSome 字符串解密器 v1.1</span><br><span class="line">============================================================</span><br><span class="line"></span><br><span class="line">[*] 批量解密模式...</span><br><span class="line">============================================================</span><br><span class="line">doSome 字符串解密结果</span><br><span class="line">============================================================</span><br><span class="line">[  28] @ 0x372c4: &quot;Author: saitexie walterjxli&quot;</span><br><span class="line">[  59] @ 0x372e3: &quot;Do you know how unity mono works?&quot;</span><br><span class="line">[  96] @ 0x37308: &quot;res/drawable-xhdpi-v4/ -&gt; assets/bin/Data/Managed/&quot;</span><br><span class="line">[ 150] @ 0x3733e: &quot;initialize&quot;</span><br><span class="line">[ 164] @ 0x3734c: &quot;()I&quot;</span><br><span class="line">[ 171] @ 0x37353: &quot;com/tencent/games/sec2021/Sec2021Application&quot;</span><br><span class="line">[ 219] @ 0x37383: &quot;com/tencent/games/sec2021/Sec2021IPC&quot;</span><br><span class="line">[ 259] @ 0x373ab: &quot;hack detected, risk score:%d&quot;</span><br><span class="line">[ 291] @ 0x373cb: &quot;getApplicationInfo&quot;</span><br><span class="line">[ 313] @ 0x373e1: &quot;()Landroid/content/pm/ApplicationInfo;&quot;</span><br><span class="line">[ 355] @ 0x3740b: &quot;getFilesDir&quot;</span><br><span class="line">[ 370] @ 0x3741a: &quot;()Ljava/io/File;&quot;</span><br><span class="line">[ 390] @ 0x3742e: &quot;sourceDir&quot;</span><br><span class="line">[ 403] @ 0x3743b: &quot;packageName&quot;</span><br><span class="line">[ 418] @ 0x3744a: &quot;nativeLibraryDir&quot;</span><br><span class="line">[ 438] @ 0x3745e: &quot;getAbsolutePath&quot;</span><br><span class="line">[ 457] @ 0x37471: &quot;/proc/self/status&quot;</span><br><span class="line">[ 478] @ 0x37486: &quot;TracerPid:&quot;</span><br><span class="line">[ 492] @ 0x37494: &quot;diediedie&quot;</span><br><span class="line">[ 505] @ 0x374a1: &quot;/proc/self/maps&quot;</span><br><span class="line">[ 524] @ 0x374b4: &quot;rb&quot;</span><br><span class="line">[ 530] @ 0x374ba: &quot;delete&quot;</span><br><span class="line">[ 540] @ 0x374c4: &quot;%zx-%zx %c%c%c%c %x %x:%x %u %s&quot;</span><br><span class="line">[ 575] @ 0x374e7: &quot;android/os/Debug&quot;</span><br><span class="line">[ 595] @ 0x374fb: &quot;isDebuggerConnected&quot;</span><br><span class="line">[ 618] @ 0x37512: &quot;sec2021&quot;</span><br><span class="line">[ 629] @ 0x3751d: &quot;getClass&quot;</span><br><span class="line">[ 641] @ 0x37529: &quot;getName&quot;</span><br><span class="line">[ 652] @ 0x37534: &quot;getSuperclass&quot;</span><br><span class="line">[ 669] @ 0x37545: &quot;android/app/Application&quot;</span><br><span class="line">[ 696] @ 0x37560: &quot;java/lang/Class&quot;</span><br><span class="line">[ 715] @ 0x37573: &quot;()Ljava/lang/Class;&quot;</span><br><span class="line">[ 738] @ 0x3758a: &quot;()Landroid/content/pm/ApplicationInfo;&quot;</span><br><span class="line">[ 780] @ 0x375b4: &quot;()Ljava/io/File;&quot;</span><br><span class="line">[ 800] @ 0x375c8: &quot;()Ljava/lang/String;&quot;</span><br><span class="line">[ 824] @ 0x375e0: &quot;Assembly-CSharp.dll&quot;</span><br><span class="line">[ 847] @ 0x375f7: &quot;Mono.Security.dll&quot;</span><br><span class="line">[ 868] @ 0x3760c: &quot;mscorlib.dll&quot;</span><br><span class="line">[ 884] @ 0x3761c: &quot;System.Core.dll&quot;</span><br><span class="line">[ 903] @ 0x3762f: &quot;System.dll&quot;</span><br><span class="line">[ 917] @ 0x3763d: &quot;UnityEngine.dll&quot;</span><br><span class="line">[ 936] @ 0x37650: &quot;UnityEngine.Networking.dll&quot;</span><br><span class="line">[ 966] @ 0x3766e: &quot;UnityEngine.PlaymodeTestsRunner.dll&quot;</span><br><span class="line">[1005] @ 0x37695: &quot;UnityEngine.UI.dll&quot;</span><br><span class="line">[1027] @ 0x376ab: &quot;base.apk&quot;</span><br><span class="line">[1039] @ 0x376b7: &quot;android/content/Context&quot;</span><br><span class="line">[1066] @ 0x376d2: &quot;()Ljava/lang/ClassLoader;&quot;</span><br><span class="line">[1095] @ 0x376ef: &quot;()Ljava/lang/String;&quot;</span><br><span class="line">[1119] @ 0x37707: &quot;zip file&quot;</span><br><span class="line">[1131] @ 0x37713: &quot;libsec2021.so&quot;</span><br><span class="line">[1148] @ 0x37724: &quot;%s/%s&quot;</span><br><span class="line">[1157] @ 0x3772d: &quot;dalvik.system.PathClassLoader&quot;</span><br><span class="line">[1190] @ 0x3774e: &quot;toString&quot;</span><br><span class="line">[1202] @ 0x3775a: &quot;getClassLoader&quot;</span><br><span class="line">[1220] @ 0x3776c: &quot;Ljava/lang/String;&quot;</span><br><span class="line">[1242] @ 0x37782: &quot;%s%s&quot;</span><br><span class="line">[1250] @ 0x3778a: &quot;/app/data/libbugly/crash.info&quot;</span><br><span class="line">[1283] @ 0x377ab: &quot;can you crack me?&quot;</span><br><span class="line">[1304] @ 0x377c0: &quot;__optional__&quot;</span><br><span class="line">[1320] @ 0x377d0: &quot;cc/binmt/signature/PmsHookApplication&quot;</span><br><span class="line">[1361] @ 0x377f9: &quot;com/cloudinject/feature/App&quot;</span><br><span class="line">[1392] @ 0x37818: &quot;np/manager/FuckSign&quot;</span><br><span class="line">[1415] @ 0x3782f: &quot;java/lang/ClassLoader&quot;</span><br><span class="line">[1440] @ 0x37848: &quot;findClass&quot;</span><br><span class="line">[1453] @ 0x37855: &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span><br><span class="line">[1494] @ 0x3787e: &quot;getPackageManager&quot;</span><br><span class="line">[1515] @ 0x37893: &quot;()Landroid/content/pm/PackageManager;&quot;</span><br><span class="line">[1556] @ 0x378bc: &quot;getPackageName&quot;</span><br><span class="line">[1574] @ 0x378ce: &quot;getPackageInfo&quot;</span><br><span class="line">[1592] @ 0x378e0: &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;</span><br><span class="line">[1649] @ 0x37919: &quot;signatures&quot;</span><br><span class="line">[1663] @ 0x37927: &quot;[Landroid/content/pm/Signature;&quot;</span><br><span class="line">[1698] @ 0x3794a: &quot;toByteArray&quot;</span><br><span class="line">[1713] @ 0x37959: &quot;()[B&quot;</span><br><span class="line">[1721] @ 0x37961: &quot;java/io/ByteArrayInputStream&quot;</span><br><span class="line">[1753] @ 0x37981: &quot;&lt;init&gt;&quot;</span><br><span class="line">[1763] @ 0x3798b: &quot;([B)V&quot;</span><br><span class="line">[1772] @ 0x37994: &quot;java/security/cert/CertificateFactory&quot;</span><br><span class="line">[1813] @ 0x379bd: &quot;getInstance&quot;</span><br><span class="line">[1828] @ 0x379cc: &quot;(Ljava/lang/String;)Ljava/security/cert/CertificateFactory;&quot;</span><br><span class="line">[1891] @ 0x37a0b: &quot;X.509&quot;</span><br><span class="line">[1900] @ 0x37a14: &quot;generateCertificate&quot;</span><br><span class="line">[1923] @ 0x37a2b: &quot;(Ljava/io/InputStream;)Ljava/security/cert/Certificate;&quot;</span><br><span class="line">[1982] @ 0x37a66: &quot;getEncoded&quot;</span><br><span class="line">[1996] @ 0x37a74: &quot;java/security/MessageDigest&quot;</span><br><span class="line">============================================================</span><br><span class="line">共解密 85 个字符串</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure>

<p>同时写一段注释到每个字符串所在位置，完整脚本如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">doSome 字符串解密脚本 - IDAPython</span></span><br><span class="line"><span class="string">分析结论:</span></span><br><span class="line"><span class="string">- data 数组: 0x372a8 (加密数据源)</span></span><br><span class="line"><span class="string">- bss_data: 0x39998 (解密结果存储)  </span></span><br><span class="line"><span class="string">- key_table: unk_34EB7 (密钥指针), 使用负偏移访问</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">解密算法 (从汇编分析):</span></span><br><span class="line"><span class="string">1. data[idx] = key1 (异或密钥, 存储在R8)</span></span><br><span class="line"><span class="string">2. data[idx+1] = key2</span></span><br><span class="line"><span class="string">3. length = key1 ^ key2</span></span><br><span class="line"><span class="string">4. 对于每个字节 i:</span></span><br><span class="line"><span class="string">   - 计算 key_idx = (i / 17) * 17  (使用UMULL + LSR实现)</span></span><br><span class="line"><span class="string">   - key_byte = unk_34EB7[-key_idx] (负偏移, 并且R1在循环中递增)</span></span><br><span class="line"><span class="string">   - decrypted[i] = data[idx+2+i] ^ key1 ^ key_byte</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">关键汇编 (0x1F26C - 0x1F298):</span></span><br><span class="line"><span class="string">    UMULL R4, R6, R0, R7    ; R7 = 0xF0F0F0F1, 计算 i / 17</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    MOV R6, R6, LSR#4       ; R6 = i / 17</span></span><br><span class="line"><span class="string">    ADD R6, R6, R6, LSL#4   ; R6 = (i/17) * 17</span></span><br><span class="line"><span class="string">    LDRB R6, [R1, -R6]      ; R1 = unk_34EB7, 取 unk_34EB7[-R6]</span></span><br><span class="line"><span class="string">    ADD R1, R1, #1          ; R1 递增</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">实际效果: key_table[i % 17], 从 unk_34EB7 开始, 顺序访问</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============== 配置区 ==============</span></span><br><span class="line">DATA_ADDR = <span class="number">0x372a8</span>       <span class="comment"># data 数组基址</span></span><br><span class="line">BSS_DATA_ADDR = <span class="number">0x39998</span>   <span class="comment"># bss_data 数组基址  </span></span><br><span class="line">KEY_TABLE_REF = <span class="number">0x34EB7</span>   <span class="comment"># unk_34EB7 - 密钥表引用点</span></span><br><span class="line">KEY_TABLE_LEN = <span class="number">17</span>        <span class="comment"># 密钥表长度 (0x11)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============== 辅助函数 ==============</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bytes_at</span>(<span class="params">addr, size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从IDB读取字节&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([idc.get_wide_byte(addr + i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_string</span>(<span class="params">idx</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密单个字符串 - 完全模拟汇编逻辑</span></span><br><span class="line"><span class="string">    @param idx: data数组中的起始索引 (传递给doSome的参数)</span></span><br><span class="line"><span class="string">    @return: (解密后的字符串, 原始长度, 下一个索引)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    汇编逻辑模拟:</span></span><br><span class="line"><span class="string">    R1 初始化为 unk_34EB7</span></span><br><span class="line"><span class="string">    循环中:</span></span><br><span class="line"><span class="string">        key_idx = (i / 17) * 17  </span></span><br><span class="line"><span class="string">        key_byte = R1[-key_idx], 然后 R1++</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    等价于: key_byte = unk_34EB7[i] - unk_34EB7[(i/17)*17] = unk_34EB7[i % 17]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取 key1 (data_171/R8) 和 key2</span></span><br><span class="line">    key1 = idc.get_wide_byte(DATA_ADDR + idx)       <span class="comment"># data[idx]</span></span><br><span class="line">    key2 = idc.get_wide_byte(DATA_ADDR + idx + <span class="number">1</span>)   <span class="comment"># data[idx+1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算字符串长度: v9 = v8 ^ data_171</span></span><br><span class="line">    length = key1 ^ key2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;&quot;</span>, <span class="number">0</span>, idx + <span class="number">4</span>)  <span class="comment"># 空字符串，跳过header + checksum</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解密循环 - 精确模拟汇编</span></span><br><span class="line">    <span class="comment"># R1 = unk_34EB7, 每次迭代 R1++</span></span><br><span class="line">    <span class="comment"># key_idx = (i / 17) * 17</span></span><br><span class="line">    <span class="comment"># key_byte = R1[-key_idx] = unk_34EB7[i - key_idx] = unk_34EB7[i % 17]</span></span><br><span class="line">    </span><br><span class="line">    decrypted = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        enc_byte = idc.get_wide_byte(DATA_ADDR + idx + <span class="number">2</span> + i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟: UMULL R4, R6, R0, R7 (R7=0xF0F0F0F1) + LSR#4 + ADD</span></span><br><span class="line">        <span class="comment"># 这是 ARM 除以 17 的优化: i / 17</span></span><br><span class="line">        key_idx = (i // KEY_TABLE_LEN) * KEY_TABLE_LEN</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># LDRB R6, [R1, -R6] 其中 R1 = unk_34EB7 + i</span></span><br><span class="line">        <span class="comment"># 所以实际是: unk_34EB7[i - key_idx] = unk_34EB7[i % 17]</span></span><br><span class="line">        key_offset = i - key_idx  <span class="comment"># = i % 17</span></span><br><span class="line">        key_byte = idc.get_wide_byte(KEY_TABLE_REF + key_offset)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># decrypted = enc ^ key1 ^ key_byte</span></span><br><span class="line">        dec_byte = enc_byte ^ key1 ^ key_byte</span><br><span class="line">        decrypted.append(dec_byte)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试解码为字符串</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = decrypted.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = decrypted.decode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            result = decrypted.<span class="built_in">hex</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下一个索引 = 当前索引 + 2(header) + length + 2(checksum + terminator)</span></span><br><span class="line">    next_idx = idx + <span class="number">2</span> + length + <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (result, length, next_idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_checksum</span>(<span class="params">data_bytes</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算XOR校验和&quot;&quot;&quot;</span></span><br><span class="line">    checksum = <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> data_bytes:</span><br><span class="line">        checksum ^= b</span><br><span class="line">    <span class="keyword">return</span> checksum &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_all_strings</span>(<span class="params">max_count=<span class="number">100</span>, max_offset=<span class="number">2000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    批量解密所有字符串</span></span><br><span class="line"><span class="string">    @param max_count: 最大解密数量</span></span><br><span class="line"><span class="string">    @param max_offset: 最大偏移量限制</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    results = []</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;doSome 字符串解密结果&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> count &lt; max_count <span class="keyword">and</span> idx &lt; max_offset:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            decrypted, length, next_idx = decrypt_string(idx)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> length &gt; <span class="number">0</span> <span class="keyword">and</span> length &lt; <span class="number">256</span>:  <span class="comment"># 合理的字符串长度</span></span><br><span class="line">                <span class="comment"># 过滤掉不可打印的垃圾数据</span></span><br><span class="line">                <span class="keyword">if</span> decrypted <span class="keyword">and</span> <span class="built_in">all</span>(c.isprintable() <span class="keyword">or</span> c <span class="keyword">in</span> <span class="string">&#x27;\r\n\t&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> decrypted):</span><br><span class="line">                    results.append(&#123;</span><br><span class="line">                        <span class="string">&#x27;index&#x27;</span>: idx,</span><br><span class="line">                        <span class="string">&#x27;data_addr&#x27;</span>: <span class="built_in">hex</span>(DATA_ADDR + idx),</span><br><span class="line">                        <span class="string">&#x27;length&#x27;</span>: length,</span><br><span class="line">                        <span class="string">&#x27;decrypted&#x27;</span>: decrypted</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;idx:4d&#125;</span>] @ <span class="subst">&#123;DATA_ADDR + idx:#x&#125;</span>: \&quot;<span class="subst">&#123;decrypted&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 移动到下一个条目</span></span><br><span class="line">            <span class="keyword">if</span> next_idx &lt;= idx:</span><br><span class="line">                idx += <span class="number">1</span>  <span class="comment"># 防止死循环</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx = next_idx</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error at idx <span class="subst">&#123;idx&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共解密 <span class="subst">&#123;<span class="built_in">len</span>(results)&#125;</span> 个字符串&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_by_param</span>(<span class="params">param_value</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据 doSome 的参数值解密</span></span><br><span class="line"><span class="string">    这是最精确的方式，直接模拟 doSome(param) 的行为</span></span><br><span class="line"><span class="string">    @param param_value: 传递给 doSome 的参数值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    decrypted, length, _ = decrypt_string(param_value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;doSome(<span class="subst">&#123;param_value&#125;</span>) = \&quot;<span class="subst">&#123;decrypted&#125;</span>\&quot; (len=<span class="subst">&#123;length&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_doSome_calls</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找所有调用 doSome 的位置并提取参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dosome_addr = idc.get_name_ea_simple(<span class="string">&quot;doSome&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> dosome_addr == idc.BADADDR:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未找到 doSome 函数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;doSome 函数地址: <span class="subst">&#123;dosome_addr:#x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    calls = []</span><br><span class="line">    <span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(dosome_addr):</span><br><span class="line">        caller_addr = xref.frm</span><br><span class="line">        caller_func = idaapi.get_func(caller_addr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> caller_func:</span><br><span class="line">            func_name = idc.get_func_name(caller_func.start_ea)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func_name = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 尝试获取参数值 (ARM/Thumb): 往前查找设置 R0 的指令</span></span><br><span class="line">        <span class="comment"># 优化策略: 往前查找 10 条指令，根据指令长度自动回溯</span></span><br><span class="line">        param = <span class="literal">None</span></span><br><span class="line">        curr_search_addr = caller_addr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            curr_search_addr = idc.prev_head(curr_search_addr)</span><br><span class="line">            <span class="keyword">if</span> curr_search_addr == idc.BADADDR:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            mnem = idc.print_insn_mnem(curr_search_addr)</span><br><span class="line">            <span class="comment"># 特征识别:</span></span><br><span class="line">            <span class="comment"># 1. MOV R0, #imm / MOVS R0, #imm</span></span><br><span class="line">            <span class="comment"># 2. MOVW R0, #imm</span></span><br><span class="line">            <span class="comment"># 3. LDR R0, [PC, #offset] (常量池加载)</span></span><br><span class="line">            <span class="keyword">if</span> mnem <span class="keyword">in</span> (<span class="string">&#x27;MOV&#x27;</span>, <span class="string">&#x27;MOVS&#x27;</span>, <span class="string">&#x27;MOVW&#x27;</span>, <span class="string">&#x27;LDR&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> idc.get_operand_type(curr_search_addr, <span class="number">0</span>) == idc.o_reg <span class="keyword">and</span> idc.get_operand_value(curr_search_addr, <span class="number">0</span>) == <span class="number">0</span>: <span class="comment"># 0 = R0</span></span><br><span class="line">                    op_type = idc.get_operand_type(curr_search_addr, <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> op_type <span class="keyword">in</span> (idc.o_imm, idc.o_mem):</span><br><span class="line">                        op_value = idc.get_operand_value(curr_search_addr, <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">if</span> op_value != idc.BADADDR:</span><br><span class="line">                            <span class="comment"># 如果是 LDR R0, [PC, #off]，get_operand_value 会直接返回常量池里的值</span></span><br><span class="line">                            param = op_value</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> param <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                decrypted, length, _ = decrypt_string(param)</span><br><span class="line">                calls.append(&#123;</span><br><span class="line">                    <span class="string">&#x27;call_addr&#x27;</span>: caller_addr,</span><br><span class="line">                    <span class="string">&#x27;func_name&#x27;</span>: func_name,</span><br><span class="line">                    <span class="string">&#x27;param&#x27;</span>: param,</span><br><span class="line">                    <span class="string">&#x27;decrypted&#x27;</span>: decrypted</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;caller_addr:#x&#125;</span> in <span class="subst">&#123;func_name&#125;</span>: doSome(<span class="subst">&#123;param&#125;</span>) = \&quot;<span class="subst">&#123;decrypted&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;caller_addr:#x&#125;</span> in <span class="subst">&#123;func_name&#125;</span>: doSome(<span class="subst">&#123;param&#125;</span>) = &lt;解密失败&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            calls.append(&#123;</span><br><span class="line">                <span class="string">&#x27;call_addr&#x27;</span>: caller_addr,</span><br><span class="line">                <span class="string">&#x27;func_name&#x27;</span>: func_name,</span><br><span class="line">                <span class="string">&#x27;param&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                <span class="string">&#x27;decrypted&#x27;</span>: <span class="literal">None</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;caller_addr:#x&#125;</span> in <span class="subst">&#123;func_name&#125;</span>: doSome(?) = &lt;参数未知&gt;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> calls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_comments</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在所有 doSome 调用点添加解密后的注释</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    calls = find_doSome_calls()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> call <span class="keyword">in</span> calls:</span><br><span class="line">        <span class="keyword">if</span> call[<span class="string">&#x27;decrypted&#x27;</span>]:</span><br><span class="line">            <span class="comment"># 添加注释</span></span><br><span class="line">            comment = <span class="string">f&quot;doSome(<span class="subst">&#123;call[<span class="string">&#x27;param&#x27;</span>]&#125;</span>) = \&quot;<span class="subst">&#123;call[<span class="string">&#x27;decrypted&#x27;</span>]&#125;</span>\&quot;&quot;</span></span><br><span class="line">            idc.set_cmt(call[<span class="string">&#x27;call_addr&#x27;</span>], comment, <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;已添加注释 @ <span class="subst">&#123;call[<span class="string">&#x27;call_addr&#x27;</span>]:#x&#125;</span>: <span class="subst">&#123;comment&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n共添加 <span class="subst">&#123;<span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> c <span class="keyword">in</span> calls <span class="keyword">if</span> c[<span class="string">&#x27;decrypted&#x27;</span>])&#125;</span> 个注释&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============== 主入口 ==============</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;doSome 字符串解密器 v1.1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">60</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式1: 批量解密所有字符串</span></span><br><span class="line">    <span class="comment"># print(&quot;[*] 批量解密模式...&quot;)</span></span><br><span class="line">    results = decrypt_all_strings(max_count=<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式2: 查找调用点并解密</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n[*] 查找 doSome 调用点...&quot;</span>)</span><br><span class="line">    <span class="comment"># find_doSome_calls()</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式3: 添加注释到IDB</span></span><br><span class="line">    patch_comments()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式4: 单个解密测试</span></span><br><span class="line">    <span class="comment"># decrypt_by_param(0)</span></span><br><span class="line">    <span class="comment"># decrypt_by_param(100)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完所有字符串所在位置就确定了<br><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205121247357.png" alt="img"></p>
<hr>
<h2 id="0x02-结束了？"><a href="#0x02-结束了？" class="headerlink" title="0x02 结束了？"></a>0x02 结束了？</h2><p>再回到frida检测时候弹出的字符串是 hack detected, type:frida，然后就程序就退出了，那么通过该字符串定位到此处，不难就发现了</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205121247382.png" alt="img"></p>
<p>既然确定了退出的地方，那么其实可以跳过如何检测的逻辑，直接结束本题了。</p>
<h3 id="P-Z的复现碎碎念"><a href="#P-Z的复现碎碎念" class="headerlink" title="P.Z的复现碎碎念"></a><strong>P.Z的复现碎碎念</strong></h3><p>但现在毕竟是在复现题目，是为了学到更多东西，我开始去理清整个加载流程，因为还有很多检测加载细节。</p>
<p>所以现在就是<strong>分岔口</strong>，由于已经知道检测后退出的地方，一种选择可以直接去 patch 重签名，直接跟着其他 wp 即可，另一种选择就是去认真审计一下加载的流程，检测的流程，更加仔细感受一下整个题目。</p>
<p>再者我在这题中不想调试，原因也是很多时候其实不好调试，一般都是通过模拟执行或者 Hook 框架来确定一些值，当然这题其实能调，过往我也喜欢调试来确定，但是这题我想锻炼通过审计、模拟执行以及 Hook 框架来处理问题。</p>
<p>我认为看一篇文章最核心的还是思考作者如何想到这一点，往往文章中缺失的一点是作者在写这篇文章的思考过程与试错点，这些过程写起来很麻烦而且因人而异，但我写 write up 会更多的写是怎么思考以及试错后得到信息与解决方法，如果只是这里 patch 一下，那里跑个脚本，其实学不到什么东西，我的整个分析也许做不到足够细，但我想我在这篇文章中尽量把大局整理明白，还有些细节与思考需要读者自行去尝试。</p>
<hr>
<h2 id="0x03-检测处理"><a href="#0x03-检测处理" class="headerlink" title="0x03 检测处理"></a>0x03 检测处理</h2><h3 id="程序加载流程"><a href="#程序加载流程" class="headerlink" title="程序加载流程"></a>程序加载流程</h3><p>先开始理清整个加载流程</p>
<ol>
<li><p>Zygote 进程：</p>
<ul>
<li>它是所有 Android 应用的父进程。</li>
<li>当你运行 <strong>frida -f</strong> 时，Frida 会在 Zygote fork 出子进程的一瞬间注入 frida-agent.so。此时应用的代码还没开始跑。</li>
</ul>
</li>
<li><p>应用进程启动 (Java 早期)：</p>
<ul>
<li>ActivityThread 启动。</li>
<li>根据 <strong>AndroidManifest.xml</strong> 实例化 Application 对象，在这题就是 Sec2021Application。</li>
</ul>
</li>
<li><p>System.loadLibrary(“sec2021”) 触发 (Java 层)：</p>
<ul>
<li>这是在 static 块里执行的，意味着只要 Sec2021Application 类被加载，它就会跑。</li>
<li><strong>System.loadLibrary</strong> 内部会调用 Runtime.nativeLoad()。</li>
</ul>
</li>
<li><p>进入 Native 层 (Linker 阶段)：</p>
<ul>
<li>Runtime.nativeLoad() 最终调用 C 库里的 dlopen(“libsec2021.so”)。</li>
<li>Linker (ld-android.so) 开始工作：</li>
<li>它把 libsec2021.so 映射到内存。</li>
<li><strong>.init_array 执行</strong>：这是 SO 文件里定义的 C++ 全局构造函数。注意：此时 JNI_OnLoad 还没跑！ 很多硬核检测（比如检测 Frida 端口、检测断点）会写在这里。</li>
</ul>
</li>
<li><p>JNI 握手 (Native 层)：</p>
<ul>
<li>Linker 完成后，虚拟机（ART）会寻找并执行 SO 里的 <strong>JNI_OnLoad</strong>(JavaVM* vm, void* reserved)。</li>
<li>通常在这里进行动态注册（<strong>RegisterNatives</strong>），将 Java 层的 native int initialize() 绑定到 Native 层的函数地址。</li>
</ul>
</li>
<li><p>回到 Java 层 (<strong>attachBaseContext</strong>)：</p>
<ul>
<li>SO 加载完毕，static 块执行完。</li>
<li>系统调用 attachBaseContext(Context context)。</li>
<li>**执行 initialize()**：这是分析的 initialize_process 真正被触发的地方。</li>
</ul>
</li>
</ol>
<p>现在给出每个细节依据，先从 <strong>AndroidManifest.xml</strong> 找到了<br>android:name=”com.tencent.games.sec2021.Sec2021Application”，确定了这是apk启动的入口点，在该类中。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205144542858.png" alt="img"></p>
<p>先是 System.loadLibrary(“sec2021”)，那么运行了 init_array，去 ida 审计发现有两个函数，第一个 init 函数其实就是初始化 method（第二个 init 函数不重要）。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205144607317.png" alt="img"></p>
<p>随后去看 JNIOnload，通过 java 层会调用 native 层的 initialize 函数，而且 init_array 会初始化了 methods，不难想象 JNIOnload 里是动态注册该函数的过程。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205144701919.png" alt="img"></p>
<p>JNIOnload 执行完后，返回运行到 attachBaseContext 方法，其中执行 initialize naitive 函数。</p>
<p>至此，整个运行流程就明白了，不难猜测检测函数都在 initialize native 函数进行初始化的（毕竟 init_array 与 JNIOnload 无事发生），这里 frida 等 libsec2021.so 加载了 hook 上即可。</p>
<h3 id="intialize-函数"><a href="#intialize-函数" class="headerlink" title="intialize 函数"></a><strong>intialize 函数</strong></h3><p>开始审计 initialize 函数，该函数地址在 init_array 初始化 methods 的时候就可以找到是在 5464 地址，这里 coreObj 初始化了一个对象，后面经常使用。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205170451460.png" alt="img"></p>
<p>经过初始化后可以发现各种检测函数的注册是在 initialize_process，在函数刚开始的地方，将一些函数注册到了刚刚初始化的对象上，且这些注册函数还上了虚假控制流和控制流平坦化。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205171005221.png" alt="img"></p>
<p>显然是里面有好康的但出题人不让康，所以上了不好康的混淆，这里直接猜测里面就是检测 frida ida 这些，因为在上面的小节我们已经把字符串混淆都处理差不多了，没有发现 frida、ida 这些字符串，说明大概率就在这里面了。</p>
<p>接下来也都是一些函数注册到了刚刚的结构体上，手动翻了这些函数，不过逆向的角度来说不太重要，我们关注点是哪里检测的问题，直到翻到 initialize_process 末尾，调用到了之前标记的函数。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205171229013.png" alt="img"></p>
<p>这里我的标记链是 alreadyChecked_c -&gt; alreadyChecked_b -&gt; alreadyChecked_a，而 alreadyChecked_a 就是检测到 hack detected, type:%s 退出的地方。</p>
<h3 id="Frida-过检测"><a href="#Frida-过检测" class="headerlink" title="Frida 过检测"></a>Frida 过检测</h3><p>刚刚的理清流程、审计函数主要是分析了</p>
<ol>
<li>理清整个程序加载流程，为了适当的时机 hook</li>
<li>定位检测函数注册流程，思考如何处理<br>那么现在的目标就是查看哪里还调用了 alreadyChecked_c 这个函数，因为一旦进入该函数说明已经被检测到，然后即将要退出了。</li>
</ol>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205172017485.png" alt="img"></p>
<p>   于是可以发现这几个调用点，基本上都可以回溯到 intialize 函数进行了注册，作为逆向可以不进行关注注册细节，我们只需要分析其中一个调用逻辑即可，就拿刚刚 initialize_process 的末尾来举例，我们只需要把 BEQ 直接 patch 成 B，恒跳转到不会失败的分支即可。</p>
<p>   <img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205172522815.png" alt="img"></p>
<p>   同样处理其他几个调用点，写一个 frida 脚本（frida版本 16.1.4，Android 10，Pixel 3XL)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g_libsec_hooked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_dlopen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Hook 两个加载函数，因为不同 Android 版本/场景使用不同的函数</span></span><br><span class="line">    <span class="keyword">var</span> dlopen_funcs = [<span class="string">&quot;dlopen&quot;</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    dlopen_funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func_name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> addr = Module.findExportByName(<span class="literal">null</span>, func_name);</span><br><span class="line">        <span class="keyword">if</span> (addr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[*] Hooking &quot;</span> + func_name + <span class="string">&quot; at&quot;</span>, addr);</span><br><span class="line">            Interceptor.attach(addr, &#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (pathptr !== <span class="literal">undefined</span> &amp;&amp; pathptr != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> path = ptr(pathptr).readCString();</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;[&quot;</span> + func_name + <span class="string">&quot;]&quot;</span>, path);</span><br><span class="line">                        <span class="built_in">this</span>.path = path;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.path &amp;&amp; <span class="built_in">this</span>.path.indexOf(<span class="string">&quot;libsec2021.so&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&quot;[!] libsec2021.so loaded via &quot;</span> + func_name);</span><br><span class="line">                        hook_sec2021();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Patch initialize_process 中的安全检查分支</span></span><br><span class="line"><span class="comment"> * 将条件跳转 (BEQ/BNE 等) 改为无条件跳转 (B)</span></span><br><span class="line"><span class="comment"> * 效果：无论检查函数返回什么，都跳过失败处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_sec2021</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_libsec_hooked) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] libsec2021.so already hooked, skipping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> libbase = Module.findBaseAddress(<span class="string">&quot;libsec2021.so&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (libbase == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[-] libsec2021.so not found&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g_libsec_hooked = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[+] libsec2021.so base:&quot;</span>, libbase);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要 patch 的地址列表</span></span><br><span class="line">    <span class="comment">// 将条件跳转指令的条件码改为 0xEA (Always)，使其变为无条件跳转</span></span><br><span class="line">    <span class="keyword">var</span> patch_offsets = [</span><br><span class="line">        <span class="number">0x1CFA4</span>,</span><br><span class="line">        <span class="number">0x1D064</span>,</span><br><span class="line">        <span class="number">0x20918</span>,</span><br><span class="line">        <span class="number">0x20930</span>,</span><br><span class="line">        <span class="number">0x2070C</span>,</span><br><span class="line">        <span class="number">0x20A4C</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    patch_offsets.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">patch_offset</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> patch_addr = libbase.add(patch_offset);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] Patching at offset 0x&quot;</span> + patch_offset.toString(<span class="number">16</span>) + <span class="string">&quot; -&gt; &quot;</span>, patch_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取原始字节确认</span></span><br><span class="line">        <span class="keyword">var</span> original_bytes = patch_addr.readByteArray(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[*] Original bytes:&quot;</span>, hexdump(original_bytes, &#123; <span class="attr">length</span>: <span class="number">4</span>, <span class="attr">header</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改内存保护并写入</span></span><br><span class="line">        Memory.protect(patch_addr, <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将条件码改为 EA (Always)</span></span><br><span class="line">        <span class="comment">// ARM 指令是小端序，条件码在最高字节 (offset +3)</span></span><br><span class="line">        patch_addr.add(<span class="number">3</span>).writeU8(<span class="number">0xEA</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证修改</span></span><br><span class="line">        <span class="keyword">var</span> patched_bytes = patch_addr.readByteArray(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;[+] Patched bytes:&quot;</span>, hexdump(patched_bytes, &#123; <span class="attr">length</span>: <span class="number">4</span>, <span class="attr">header</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[+] All &quot;</span> + patch_offsets.length + <span class="string">&quot; security check bypasses applied!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] Script loaded, waiting for libsec2021.so...&quot;</span>);</span><br><span class="line">    hook_dlopen();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br><span class="line"><span class="comment">// frida -U -f com.personal.rocketmouse -l sec2021.js</span></span><br></pre></td></tr></table></figure>

<p>成功 patch，也不会被检测到退出了！</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205173239778.png" alt="img"></p>
<hr>
<h2 id="0x04-整体逻辑梳理"><a href="#0x04-整体逻辑梳理" class="headerlink" title="0x04 整体逻辑梳理"></a>0x04 整体逻辑梳理</h2><p>既然检测已过，且该程序的加解密都是落地的，所以基本上接下来没有什么困难的了。</p>
<h3 id="获取-Assembly-CSharp"><a href="#获取-Assembly-CSharp" class="headerlink" title="获取 Assembly-CSharp"></a>获取 Assembly-CSharp</h3><p>先去获得正确的 Assembly-CSharp.dll，同样开始文章刚开始的思路，去 hook libmono.so 的 mono_image_open_from_data_with_name 函数。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260205221244409.png" alt="img"></p>
<p>去看了眼该函数，发现该函数<strong>不能正常反编译</strong>（这属于系统函数所以不正常），但也不是花指令之类，所以估计是sec里对mono还进行了修改（从之前字符串解密的的text与libmono也有感觉）。</p>
<p>但具体如何修改mono其实也不用在意，只需要找一个合适的时机 dump 出 mono 即可看到 libsec 是修改后的 mono 了，也就是只要落地，那么不管咋加密都能 dump 出来，毕竟 frida 检测都过了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dumpSo</span>(<span class="params">soName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lib = Module.findBaseAddress(soName);</span><br><span class="line">    <span class="keyword">if</span> (lib == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;找不到该 SO: &quot;</span> + soName);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取模块详情</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = Process.getModuleByName(soName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;正在 Dump &quot;</span> + soName + <span class="string">&quot; 基址: &quot;</span> + <span class="built_in">module</span>.base + <span class="string">&quot; 大小: &quot;</span> + <span class="built_in">module</span>.size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentApplication = Java.use(<span class="string">&quot;android.app.ActivityThread&quot;</span>).currentApplication();</span><br><span class="line">    <span class="keyword">var</span> dir = currentApplication.getApplicationContext().getFilesDir().getPath();</span><br><span class="line">    <span class="keyword">var</span> fileName = dir + <span class="string">&quot;/dumpmemory.bin&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="keyword">new</span> File(fileName, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历所有内存分页，只读取属于该 SO 且有读取权限的部分</span></span><br><span class="line">    Process.enumerateRanges(<span class="string">&#x27;r--&#x27;</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">range</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (range.base.compare(<span class="built_in">module</span>.base) &gt;= <span class="number">0</span> &amp;&amp; </span><br><span class="line">            range.base.compare(<span class="built_in">module</span>.base.add(<span class="built_in">module</span>.size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;正在读取段: &quot;</span> + range.base + <span class="string">&quot; 权限: &quot;</span> + range.protection);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 readByteArray 之前可以先验证一次权限</span></span><br><span class="line">                <span class="keyword">var</span> buf = range.base.readByteArray(range.size);</span><br><span class="line">                file.write(buf);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">&quot;跳过不可读段: &quot;</span> + range.base);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    file.flush();</span><br><span class="line">    file.close();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Dump 完成！文件保存在: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dump 出来（可以拿SoFixer修一下，但只是看看函数也可以不修），如果对比正常的 libmono.so 会发现多个跳转，但之后的代码就一样了。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260206133904040.png" alt="img"></p>
<p>所以直接 hook sub_190C74，再根据函数原型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MonoImage* mono_image_open_from_data_with_name(</span><br><span class="line">    char *data,                // args[0]: 指向内存中 DLL 数据的指针</span><br><span class="line">    uint32_t data_len,         // args[1]: DLL 数据的字节长度</span><br><span class="line">    mono_bool need_copy,       // args[2]: 是否需要 Mono 内部拷贝这份数据</span><br><span class="line">    MonoImageOpenStatus *status, // args[3]: 返回加载状态的指针（用于错误排查）</span><br><span class="line">    mono_bool refonly,         // args[4]: 是否以仅反射模式打开</span><br><span class="line">    const char *name           // args[5]: 关键！DLL 的名称或路径</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>正常的 hook dump Assembly-CSharp.dll 出来即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dump_memory</span>(<span class="params">base, size</span>) </span>&#123;  </span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> currentApplication = Java.use(<span class="string">&quot;android.app.ActivityThread&quot;</span>).currentApplication();  </span><br><span class="line">        <span class="keyword">var</span> dir = currentApplication.getApplicationContext().getFilesDir().getPath();  </span><br><span class="line">        <span class="keyword">var</span> file_path = dir + <span class="string">&quot;/dumpDLL.bin&quot;</span>;  </span><br><span class="line">        <span class="keyword">var</span> file_handle = <span class="keyword">new</span> File(file_path, <span class="string">&quot;wb&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (file_handle &amp;&amp; file_handle != <span class="literal">null</span>) &#123;  </span><br><span class="line">            Memory.protect(ptr(base), size.toInt32(), <span class="string">&#x27;rwx&#x27;</span>);  </span><br><span class="line">            <span class="keyword">var</span> libso_buffer = ptr(base).readByteArray(size.toInt32());  </span><br><span class="line">            file_handle.write(libso_buffer);  </span><br><span class="line">            file_handle.flush();  </span><br><span class="line">            file_handle.close();  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;[dump] &quot;</span>, file_path);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_mono</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> libbase = Module.findBaseAddress(<span class="string">&quot;libmono.so&quot;</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;libbase&quot;</span>, libbase);  </span><br><span class="line">    <span class="keyword">var</span> addr = Module.findExportByName(<span class="string">&quot;libmono.so&quot;</span>, <span class="string">&quot;mono_image_open_from_data_with_name&quot;</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;mono_image_open_from_data_with_name&quot;</span>, addr);  </span><br><span class="line">  </span><br><span class="line">    Interceptor.attach(Module.findExportByName(<span class="string">&quot;libmono.so&quot;</span>, <span class="string">&quot;mono_image_open_from_data_with_name&quot;</span>).add(<span class="number">4</span>), &#123;  </span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;  </span><br><span class="line">            <span class="keyword">var</span> data = args[<span class="number">0</span>];  </span><br><span class="line">            <span class="keyword">var</span> data_len = args[<span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">if</span> (data_len == <span class="number">0x2800</span>) &#123;  </span><br><span class="line">               dump_memory(data, data_len);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;mono_image_open_from_data_with_name_ori() called!&quot;</span>, data, data_len);  </span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="神秘的跳转"><a href="#神秘的跳转" class="headerlink" title="神秘的跳转"></a>神秘的跳转</h3><p>但先等等看游戏逻辑，上面分析有些细节没讲</p>
<ol>
<li>为什么是dump的大小限定在 0x2800？</li>
<li>这个跳转到底是什么，为什么直接判定 hook +4的位置就可以？<br>先再来复述一下游戏运行流程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ 安卓系统 (Android OS) ]</span><br><span class="line">       ↓</span><br><span class="line">[ Unity 引擎层 (libunity.so) ]</span><br><span class="line">       ↓</span><br><span class="line">[ Mono 虚拟机层 (libmono.so) ] &lt;--- 你可以 Hook 这里</span><br><span class="line">       ↓</span><br><span class="line">[ 托管代码层 (Assembly-CSharp.dll) ] &lt;--- 你可以直接反编译这里</span><br><span class="line">       ↓</span><br><span class="line">[ JIT 编译器 ] -&gt; [ 生成内存中的 ARM 指令 ] -&gt; [ CPU 执行 ]</span><br></pre></td></tr></table></figure>

<p>真相是该流程下 libmono.so 在正常调用到 mono_image_open_from_data_with_name 时候，做了一个跳转到 sec2021（可以 frida 看参数或者调试确定），处理过 dll 再跳回正常执行。</p>
<p>其实也是收回伏笔了，一开始我们找到的 Assembly-CSharp 静态是给加密的，所以正常读取肯定会做过处理后再使用，具体就是跳到了 0001CEE0 地址位置。</p>
<p>该函数审计可得</p>
<ol>
<li>区分目标 dll 和正常 dll</li>
<li>检测环境</li>
<li>回跳 mono_image_open_from_data_with_name</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">hook_mono_image</span><span class="params">(<span class="keyword">unsigned</span> __int8 *dll_data, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> (__fastcall *org_mono_image)(<span class="keyword">unsigned</span> __int8 *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> *); <span class="comment">// r8</span></span><br><span class="line">  <span class="keyword">int</span> dll_0; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">bool</span> check_MZ; <span class="comment">// zf</span></span><br><span class="line">  _BYTE *v13; <span class="comment">// r0</span></span><br><span class="line">  _BYTE *v14; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *sec2021_png_str; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v16; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> (__fastcall *v17)(<span class="keyword">int</span>); <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">int</span> len; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *enc1; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *enc; <span class="comment">// r5</span></span><br><span class="line">  <span class="keyword">int</span> *v23; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">char</span> key; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v25; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> (__fastcall *execute_check)(<span class="keyword">int</span>); <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">char</span> *s_sharpDll; <span class="comment">// r0</span></span><br><span class="line">  _QWORD png[<span class="number">2</span>]; <span class="comment">// [sp+8h] [bp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  org_mono_image = (<span class="keyword">int</span> (__fastcall *)(<span class="keyword">unsigned</span> __int8 *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> *))g_sec2021_o_array;</span><br><span class="line">  dll_0 = *dll_data;</span><br><span class="line">  check_MZ = dll_0 == <span class="string">&#x27;M&#x27;</span>;                      <span class="comment">// 前两位检测MZ</span></span><br><span class="line">  <span class="keyword">if</span> ( dll_0 == <span class="string">&#x27;M&#x27;</span> )                           <span class="comment">// Check PE Header (MZ)</span></span><br><span class="line">    check_MZ = dll_data[<span class="number">1</span>] == <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( check_MZ )                               <span class="comment">// 前两位是MZ</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !name )</span><br><span class="line">      <span class="keyword">goto</span> check_and_load;</span><br><span class="line"></span><br><span class="line">    s_sharpDll = doSome(<span class="number">824</span>);                   <span class="comment">// Get string &quot;Assembly-CSharp.dll&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ( !strcasestr(name, s_sharpDll) )</span><br><span class="line">      <span class="keyword">goto</span> check_and_load;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v13 = (_BYTE *)*((_DWORD *)getGloabCtx() + <span class="number">11</span>);</span><br><span class="line">  v14 = &amp;unk_327A8;</span><br><span class="line">  <span class="keyword">if</span> ( v13 )</span><br><span class="line">    v14 = v13;</span><br><span class="line">  <span class="keyword">if</span> ( !*v14 )</span><br><span class="line">    <span class="keyword">goto</span> check_and_load;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  init(png);</span><br><span class="line">  sec2021_png_str = (<span class="keyword">unsigned</span> __int8 *)doSome(<span class="number">2137</span>);<span class="comment">// Get resource path &quot;res/drawable-xhdpi-v4/sec2021.png&quot;</span></span><br><span class="line">  <span class="keyword">if</span> ( sub_6D48((<span class="keyword">int</span>)v14, sec2021_png_str, (<span class="keyword">int</span>)png)</span><br><span class="line">    || (len = may_cal_len((<span class="keyword">int</span>)png) - <span class="number">0x410B</span>, (enc1 = (<span class="keyword">unsigned</span> __int8 *)<span class="built_in">malloc</span>(len)) == <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    free_png((<span class="keyword">int</span>)png);</span><br><span class="line">check_and_load:</span><br><span class="line">    v16 = (_DWORD *)sub_18B00();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( sub_18CEC(v16, (<span class="keyword">unsigned</span> __int8 *)name, a2, dll_data) )<span class="comment">// 检测</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v17 = alreadyChecked_c();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v17(<span class="number">2048</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> org_mono_image(dll_data, a2, a3, a4, a5, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enc = enc1;</span><br><span class="line">  qmemcpy(enc1, (<span class="keyword">const</span> <span class="keyword">void</span> *)(sub_722C(png) + <span class="number">0x410B</span>), len);<span class="comment">// Copy encrypted DLL data from resource (offset 16651)</span></span><br><span class="line">  v23 = (<span class="keyword">int</span> *)sub_15FF4();</span><br><span class="line">  key = init_key(v23);</span><br><span class="line">  xor_decrypt_data(enc, len, key);              <span class="comment">// Decrypt the DLL data</span></span><br><span class="line"></span><br><span class="line">  v25 = (_DWORD *)sub_18B00();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( sub_18CEC(v25, (<span class="keyword">unsigned</span> __int8 *)name, len, enc) )<span class="comment">// 检测</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    execute_check = alreadyChecked_c();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    execute_check(<span class="number">2048</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v18 = org_mono_image(enc, len, a3, a4, a5, name);<span class="comment">// Call original loader with replaced DLL</span></span><br><span class="line">  free_png((<span class="keyword">int</span>)png);</span><br><span class="line">  <span class="keyword">return</span> v18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，整理一下目前所得的信息</p>
<ol>
<li>JNIOnload 动态注册 initialize</li>
<li>Java 层调用 initialize</li>
<li>initialize 里注册了各种检查函数</li>
<li>mono_image_open_from_data_with_name 开头做了一个 hook 跳到 libsec 的函数做了处理 dll</li>
<li>处理 dll 的函数加载了正确的 Assembly-CSharp，使得整个游戏正常运行</li>
</ol>
<hr>
<h2 id="0x05-实现破解版"><a href="#0x05-实现破解版" class="headerlink" title="0x05 实现破解版"></a>0x05 实现破解版</h2><p>将 dll 拖进 dnSpy，游戏逻辑很简单，直接 nop 掉检测碰到激光的分支即可。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260207122443500.png" alt="img"></p>
<p>现在要想一下如何处理 libsec 了，首先是之前在 frida 修改的检测跳转，手动去把 BEQ 改成 B 就可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patch_offsets = [</span><br><span class="line">    <span class="number">0x1CFA4</span>,</span><br><span class="line">    <span class="number">0x1D064</span>,</span><br><span class="line">    <span class="number">0x20918</span>,</span><br><span class="line">    <span class="number">0x20930</span>,</span><br><span class="line">    <span class="number">0x2070C</span>,</span><br><span class="line">    <span class="number">0x20A4C</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>检测干掉了还差一处地方，也就是 mono_image_open_from_data_with_name 入口的跳转，是特别处理了开头不是 MZ 的 dll，由于我们将 patch 好的 Assembly-CSharp，且已经实现了解密，所以不需要走 libsec 中解密的流程。</p>
<p>这里直接将过了 MZ 检测的 dll 直接去加载 dll，不去做解密操作了，同样是把这里的 BEQ 改成 B 即可。</p>
<p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260207123122403.png" alt="img"></p>
<p>然而在重打包的地方有处小坑，猜测是由于 apktool b 重打包的时候会尝试编译所有的 XML、resoureces.arsc 重新生成资源索引表，导致 libsec 读取某些资源的偏移量出问题了。</p>
<p>其实具体的检测函数我没在文中细写（分析的 i64 看附件），实际上很多检测函数要读 assets 或是其他内容进行 crc 校验等，估计是在这个过程如果用 apktool 会导致无法对应内容从而用 apktool 重打包会导致运行失败。（当然这是猜测，如果有师傅有其他理解欢迎讨论）</p>
<p>于是我们就直接用压缩软件直接打开 apk，不去解压，将目标 Assembly-CSharp 和 libsec2021 换成我们 patch 好的，再重新签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar uber-apk-signer-1.3.0.jar --apks RocketMouse.apk</span><br></pre></td></tr></table></figure>

<h3 id="没关就是开了！"><a href="#没关就是开了！" class="headerlink" title="没关就是开了！"></a>没关就是开了！</h3><p><img src="/2026/02/07/2021-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8-%E5%AE%89%E5%8D%93%E5%88%9D%E8%B5%9B/IMG-20260207124839593.png" alt="img"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.xhyeax.com/2021/04/04/gslab2021-pre-android/">https://blog.xhyeax.com/2021/04/04/gslab2021-pre-android/</a><br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?extra=page=1&filter=digest&orderby=views&typeid=342&amp;mod=viewthread&amp;tid=1420775">https://www.52pojie.cn/forum.php?extra=page%3d1%26filter%3ddigest%26orderby%3dviews%26typeid%3d342&amp;mod=viewthread&amp;tid=1420775</a><br><a target="_blank" rel="noopener" href="https://linkleyping.top/gslab2021-pre/#app%E5%88%86%E6%9E%90">https://linkleyping.top/gslab2021-pre/#app%E5%88%86%E6%9E%90</a></p>
</blockquote>

    </div>
    
    <div id = "frozen-btn" class = "center">
    <!-- <button class="green" onclick = "Change()">🎉☕一杯咖啡~</button> -->
    <button class="purple" onclick = "Change()">🍰</button>
    </div>
    
    <!-- <div class = "hide" id = "img">
        <div class="post-list">
            <article class="post-list-item">
                <div class="content">
                    <img src="/img/Coffee/AliPay.png" alt="DASCTF X SU">
                    <div class="center">
                        🍬
                    </div>
                </div>
            </article>
            <article class="post-list-item">
                <div class="content">
                    <img src="/img/Coffee/WeChat.png" alt="HFCTF2022">
                    <div class="center">
                        🍪
                    </div>
                </div>
            </article>
        </div>
    </div> -->
    <script>
            function Change()
            {
                var img = document.getElementById("img");
                if(img.className == "hide")
                {
                    img.className="";
                }
                else
                {
                    img.className="hide";
                }
            }
    </script>

    <div class="about">
        <h1>About this Post</h1>
        <p>This post is written by P.Z, licensed under <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>
    <!-- 
        
     -->
<div class="container">
<!-- <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
      serverURL: 'https://blog-api-pozeep.vercel.app/',  
      visitor: true,
      emoji: [   //这里加了一些表情 
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
      ],
       avatar: 'robohash',   //自定义默认头像为随机的机器人
       placeholder: '🍟🍰🧊🍔🍓🍫🍦🍗🍇🍉🍑🥐🍕',   //占位符
    });
  </script>
</div> -->

<!-- <span id="/2026/02/07/2021-腾讯游戏安全-安卓初赛/" class="leancloud_visitors" data-flag-title="2021 腾讯游戏安全 安卓初赛">
    <em class="post-meta-item-text">阅读量 </em>
    <i class="waline-visitor-count"></i>
</span> -->

</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Home</a>
                
                <a href="/Friends/Friends" class="item">Friends</a>
                
                <a href="/About/About" class="item">About</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/PoZeep" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/39892350" class="item">BiliBili</a>
                
            </div>
            
        </div>
        <span>&copy; 2026 P.Z<br >Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></span>
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
        
    <span id="sitetime" style="text-align: center;display:block;"></span>


</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 12, 27, 12, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "我已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了*/
    siteTime();
</script>

<!-- 在线通讯Tidio -->

<script src="//code.tidio.co/zmdcv08a6racnaer2so7xybdwby41fsa.js"></script>



        
<script src="/js/main.js"></script>

        
    </body>
</html>