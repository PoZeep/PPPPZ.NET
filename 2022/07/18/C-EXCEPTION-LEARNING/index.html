<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>C++ EXCEPTION LEARNING - P.Z&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
    
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
 
  

    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>

<meta name="generator" content="Hexo 6.0.0"></head>

<!-- //unpkg.com/@waline/client -->
<!--  -->
    <body data-color-scheme="auto">
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">P.Z&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/Diary/Diary">Diary</a>
            
            
            
            <a class="nav-item" href="/Friends/Friends">Friends</a>
            
            
            
            <a class="nav-item" href="/CTF/CTF">CTF</a>
            
            
            
            <a class="nav-item" href="/Book/Book">Book</a>
            
            
            
            <a class="nav-item" href="/Sundry/Sundry">Sundry</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/PoZeep" target="_blank">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://space.bilibili.com/39892350" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            
            
            <span>July</span>
            
            
            
            
            
            
            <span>18,</span>
            <span>2022</span>
        </div>
        

        <h2 class="title">C++ EXCEPTION LEARNING</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>关于为了复现Inflated从而看了几篇异常处理文章，由于太菜，笔记几乎是复制回来，加了自己的注释）</p>
<p>第一篇！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/3604516.html">https://www.cnblogs.com/catch/p/3604516.html</a></p>
</blockquote>
<h1 id="C-异常处理（1）"><a href="#C-异常处理（1）" class="headerlink" title="C++异常处理（1）"></a>C++异常处理（1）</h1><h2 id="异常抛出后，发生了什么事情？"><a href="#异常抛出后，发生了什么事情？" class="headerlink" title="异常抛出后，发生了什么事情？"></a>异常抛出后，发生了什么事情？</h2><ol>
<li><p>如果当前函数没有catch，就沿着函数的调用链继续往上抛，然后出现两种情况</p>
<ul>
<li><p>在某个函数中找到相应的catch</p>
</li>
<li><p>没找到相应的catch，调用 std::terminate() （这个函数是把程序abort）</p>
</li>
</ul>
</li>
<li><p>如果想找到了相应的catch，执行相应的操作</p>
<ul>
<li>程序中<strong>catch的代码块</strong>有个专有名词：<strong>Landing pad</strong></li>
</ul>
</li>
<li><p>  从抛异常到开始 -&gt; 执行Landing pad代码 这整个过程叫作<strong>Stack unwind</strong></p>
</li>
</ol>
<p><strong>Stack unwind</strong></p>
<ol>
<li> 从抛异常函数开始，对调用链上的函数逐个往前查找Landing pad</li>
<li> 如果没有找到Landing pad则把程序abort，如果找到则记下Landing pad的位置，再重新回到抛异常的函数那里开始，一帧一帧地清理调用链上各个函数内部的局部变量，直到 landing pad 所在的函数为止</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cs a; <span class="comment">// stack unwind时被析构。</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cs b;</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cs c;</span><br><span class="line">  <span class="keyword">try</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//进入这里之前， func1, func2已经被unwind.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stack unwind的过程可以简单看成函数调用的逆过程，这个过程在实现上由一个专门的stack unwind库来实现</p>
<ul>
<li><p>stack unwind库在intel平台上</p>
</li>
<li><p>属于Itanium ABI 接口中的一部分</p>
</li>
<li><p>与具体的语言无关，由系统实现</p>
</li>
<li><p><strong>任何上层语言都可以通过这个接口的基础实现各自的异常处理</strong></p>
</li>
<li><p>GCC就是通过这个接口实现C++的异常处理</p>
</li>
</ul>
<h2 id="Itanium-C-ABI"><a href="#Itanium-C-ABI" class="headerlink" title="Itanium C++ ABI"></a>Itanium C++ ABI</h2><p>ltanium C++ ABI定义了一系列函数以及数据结构来建立整个异常处理的流程及框架，主要函数包括以下列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_Unwind_RaiseException,</span><br><span class="line">_Unwind_Resume,</span><br><span class="line">_Unwind_DeleteException,</span><br><span class="line">_Unwind_GetGR,</span><br><span class="line">_Unwind_SetGR,</span><br><span class="line">_Unwind_GetIP,</span><br><span class="line">_Unwind_SetIP,</span><br><span class="line">_Unwind_GetRegionStart,</span><br><span class="line">_Unwind_GetLanguageSpecificData,</span><br><span class="line">_Unwind_ForcedUnwind</span><br></pre></td></tr></table></figure>

<p><strong>其中 _Unwind_RaiseException() 函数进行stack unwind</strong>，它在用户执行throw的时被调用</p>
<p>主要功能</p>
<ul>
<li><p>从当前函数开始，对调用链上的每一个函数都调用一个叫做 personality routine 的函数（__gxx_personality_v0）</p>
<ul>
<li> personality routine 该函数由上层的语言定义及提供实现</li>
</ul>
</li>
<li><p>_Unwind_RaiseException() 会在内部把函数栈调用现场重现，然后传给 personality routine，该函数主要做两件事情</p>
<ol>
<li>  检查当前函数是否有相对应的catch</li>
<li>  清理调用栈上的局部变量</li>
</ol>
</li>
</ul>
<p><strong>personality routine</strong></p>
<p>显然可以发现 personality routine 干的事情不就是stack unwind干的事情，所以说stack unwind主要就是通过personality routine来完成，相当于一个callback函数</p>
<ul>
<li>这些参数要注意的是第二个 actions，这是用来告诉 personality routine 当前处于哪个阶段</li>
</ul>
<ul>
<li>其他参数主要用来传递异常相关信息和当前函数上下文</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_Unwind_Reason_Code (*__personality_routine)</span><br><span class="line">        (<span class="keyword">int</span> version,</span><br><span class="line">         _Unwind_Action actions,</span><br><span class="line">         uint64 exceptionClass,</span><br><span class="line">         struct _Unwind_Exception *exceptionObject,</span><br><span class="line">         struct _Unwind_Context *context);</span><br></pre></td></tr></table></figure>



<p><strong>Stack unwind的两个阶段</strong></p>
<p>具体到调用链上的函数来说，每个函数在 unwind 过程中都会被 personality routine 遍历两次</p>
<p>以下伪代码展示 _Unwind_RaiseException() 内部的大概实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_Unwind_RaiseException(exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 第一个循环找到相应的catch断 找不到就abort</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 建立上个函数的上下文</span></span><br><span class="line">         context = <span class="built_in">build_context</span>();</span><br><span class="line">         <span class="keyword">if</span> (!context) <span class="keyword">break</span>;</span><br><span class="line">         found = <span class="built_in">personality_routine</span>(exception, context, SEARCH);</span><br><span class="line">         <span class="keyword">if</span> (found <span class="keyword">or</span> reach the end) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到了就清理函数内部</span></span><br><span class="line">    <span class="keyword">while</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        context = <span class="built_in">build_context</span>();</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">personality_routine</span>(exception, context, UNWIND);</span><br><span class="line">        <span class="keyword">if</span> (reach_catch_function) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ABI 中的函数使用到了两个自定义的数据结构，用来传递一些内部的信息（<strong>指的是 personality routine的两个参数</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Context</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> &#123;</span></span><br><span class="line">  uint64     exception_class;</span><br><span class="line">  _Unwind_Exception_Cleanup_Fn exception_cleanup;</span><br><span class="line">  uint64     private_1;</span><br><span class="line">  uint64     private_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>_Unwind_Context</strong></p>
<ul>
<li><p>这是第一个对调用者透明的结构，用于表示运行时的上下文</p>
<ul>
<li>主要就是一些寄存器的值和函数返回地址等</li>
</ul>
</li>
</ul>
<p>（接口中没找到定义，这是gcc的源码里的定义）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *reg[DWARF_FRAME_REGISTERS+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">void</span> *cfa;</span><br><span class="line">  <span class="keyword">void</span> *ra;</span><br><span class="line">  <span class="keyword">void</span> *lsda;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dwarf_eh_bases</span> <span class="title">bases</span>;</span></span><br><span class="line">  _Unwind_Word args_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>_Unwind_Exception</strong></p>
<p>unwind库里用于表示一个异常</p>
<h2 id="C-ABI"><a href="#C-ABI" class="headerlink" title="C++ ABI"></a>C++ ABI</h2><p>基于前面介绍的 ltanium ABI，<strong>编译器层面</strong>也定义了一系列 ABI 与之交互</p>
<p>当我们在代码中写下 throw xxx，编译器会分配一个数据结构 <strong>__cxa_exception</strong> 来表示该异常，该异常也有一个头部，定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">cxa_exception</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  std::type_info *    exceptionType;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*exceptionDestructor) (<span class="keyword">void</span> *); </span><br><span class="line">  unexpected_handler    unexpectedHandler;</span><br><span class="line">  terminate_handler    terminateHandler;</span><br><span class="line">  __cxa_exception *    nextException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>     handlerCount;</span><br><span class="line">  <span class="keyword">int</span>     handlerSwitchValue;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *     actionRecord;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *     languageSpecificData;</span><br><span class="line">  <span class="keyword">void</span> *     catchTemp;</span><br><span class="line">  <span class="keyword">void</span> *     adjustedPtr;</span><br><span class="line"></span><br><span class="line">  _Unwind_Exception    unwindHeader;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意最后一个变量！**_Unwind_Exception unwindHeader**，这个变量就是前面 <strong>ltanium 接口里提到的接口内部用的结构体</strong></p>
<p>当用户 throw 一个异常时，编译器会帮我们调用相应的函数分配出如下的结构</p>
<p><img src="/C-EXCEPTION-LEARNING/image-20220717215150054.png" alt="image-20220717215150054"></p>
<p>其中 _cxa_exception 就是头部，exception_obj 则是 “throw xxx” 中的 xxx，这两部分在内存中是连续的。</p>
<ul>
<li><p>异常对象由函数 __cxa_allocate_exception() 进行创建</p>
</li>
<li><p>最后由 __cxa_free_exception() 进行销毁</p>
</li>
</ul>
<p>当我们在程序里执行了抛出异常的操作，编译器为我们做了如下的事情：</p>
<ol>
<li>调用 __cxa_allocate_exception 函数，分配一个异常对象（数据结构如上）</li>
<li>调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化</li>
<li>__cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind</li>
<li>_Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine</li>
<li>该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理</li>
<li>_Unwind_RaiseException() 将控制权转到相应的catch代码</li>
<li>unwind 完成，用户代码继续执行</li>
</ol>
<p>总结的太Bravo!!</p>
<p>从C++的角度看，一个完整的异常处理流程就完成了，当然省略了很多细节</p>
<p>如 personality routine</p>
<ul>
<li><p>它是怎么知道当前 unwind 的函数是否有相应的 catch 语句？</p>
</li>
<li><p>又是怎么知道该如何处理这个函数内的局部变量</p>
</li>
</ul>
<p>只需要大概明白，personality routine本身也不知道，只有编译器知道！</p>
<p>因此在编译阶段编译器会建立一些表项来保存相应的信息，使得 personality routine 可以在运行时通过这些事，先建立起来的信息进行相应的查询</p>
<h2 id="从源码看-Unwind-过程"><a href="#从源码看-Unwind-过程" class="headerlink" title="从源码看 Unwind 过程"></a>从源码看 Unwind 过程</h2><p> unwind 的过程是从 __cxa_throw() 里开始的，请看如下源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">void</span></span><br><span class="line">__cxxabiv1::__cxa_throw (<span class="keyword">void</span> *obj, std::type_info *tinfo,</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (_GLIBCXX_CDTOR_CALLABI *dest) (<span class="keyword">void</span> *))</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">PROBE2</span> (<span class="keyword">throw</span>, obj, tinfo);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Definitely a primary.</span></span><br><span class="line">   __cxa_refcounted_exception *header = __get_refcounted_exception_header_from_obj (obj);</span><br><span class="line">   header-&gt;referenceCount = <span class="number">1</span>;</span><br><span class="line">   header-&gt;exc.exceptionType = tinfo;</span><br><span class="line">   header-&gt;exc.exceptionDestructor = dest;</span><br><span class="line">   header-&gt;exc.unexpectedHandler = std::<span class="built_in">get_unexpected</span> ();</span><br><span class="line">   header-&gt;exc.terminateHandler = std::<span class="built_in">get_terminate</span> ();</span><br><span class="line">   __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header-&gt;exc.unwindHeader.exception_class);</span><br><span class="line">   header-&gt;exc.unwindHeader.exception_cleanup = __gxx_exception_cleanup;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// see here!! It is call RaiseException to unwind stack!</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">ifdef</span> _GLIBCXX_SJLJ_EXCEPTIONS</span></span><br><span class="line">   _Unwind_SjLj_RaiseException (&amp;header-&gt;exc.unwindHeader);</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">   _Unwind_RaiseException (&amp;header-&gt;exc.unwindHeader); </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Some sort of unwinding error. Note that terminate is a handler.</span></span><br><span class="line">   __cxa_begin_catch (&amp;header-&gt;exc.unwindHeader);</span><br><span class="line">   std::<span class="built_in">terminate</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 __cxa_throw 最终调用了 _Unwind_RaiseException()，stack unwind 就此开始</p>
<p>如前面所述，unwind 分为两个阶段，分别进行搜索 catch 及清理调用栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Raise an exception, passing along the given exception object.  */</span></span><br><span class="line"></span><br><span class="line">_Unwind_Reason_Code</span><br><span class="line">_Unwind_RaiseException(struct _Unwind_Exception *exc)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Context</span> <span class="title">this_context</span>, <span class="title">cur_context</span>;</span></span><br><span class="line">  _Unwind_Reason_Code code;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">uw_init_context</span> (&amp;this_context);</span><br><span class="line">  cur_context = this_context;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phase 1: Search.  Unwind the stack, calling the personality routine</span></span><br><span class="line"><span class="comment">     with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _Unwind_FrameState fs;</span><br><span class="line"></span><br><span class="line">      code = <span class="built_in">uw_frame_state_for</span> (&amp;cur_context, &amp;fs);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (code == _URC_END_OF_STACK)</span><br><span class="line">    <span class="comment">/* Hit end of stack with no handler found.  */</span></span><br><span class="line">    <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">    <span class="comment">/* Some error encountered.  Ususally the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">       diagnose these and merely crashes.  */</span></span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fs.personality)</span><br><span class="line">    &#123;</span><br><span class="line">      code = (*fs.personality) (<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">                    exc, &amp;cur_context);</span><br><span class="line">      <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">        <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">uw_update_context</span> (&amp;cur_context, &amp;fs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Indicate to _Unwind_Resume and associated subroutines that this</span></span><br><span class="line"><span class="comment">     is not a forced unwind.  Further, note where we found a handler.  */</span></span><br><span class="line">  exc-&gt;private_1 = <span class="number">0</span>;</span><br><span class="line">  exc-&gt;private_2 = <span class="built_in">uw_identify_context</span> (&amp;cur_context);</span><br><span class="line"></span><br><span class="line">  cur_context = this_context;</span><br><span class="line">  code = _Unwind_RaiseException_Phase2 (exc, &amp;cur_context);</span><br><span class="line">  <span class="keyword">if</span> (code != _URC_INSTALL_CONTEXT)</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">uw_install_context</span> (&amp;this_context, &amp;cur_context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> _Unwind_Reason_Code</span><br><span class="line">_Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,</span><br><span class="line">                  struct _Unwind_Context *context)</span><br><span class="line">&#123;</span><br><span class="line">  _Unwind_Reason_Code code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _Unwind_FrameState fs;</span><br><span class="line">      <span class="keyword">int</span> match_handler;</span><br><span class="line"></span><br><span class="line">      code = <span class="built_in">uw_frame_state_for</span> (context, &amp;fs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Identify when we&#x27;ve reached the designated handler context.  */</span></span><br><span class="line">      match_handler = (<span class="built_in">uw_identify_context</span> (context) == exc-&gt;private_2</span><br><span class="line">               ? _UA_HANDLER_FRAME : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">    <span class="comment">/* Some error encountered.  Usually the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">       diagnose these and merely crashes.  */</span></span><br><span class="line">      <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fs.personality)</span><br><span class="line">      &#123;</span><br><span class="line">        code = (*fs.personality) (<span class="number">1</span>, _UA_CLEANUP_PHASE | match_handler,</span><br><span class="line">                    exc-&gt;exception_class, exc, context);</span><br><span class="line">        <span class="keyword">if</span> (code == _URC_INSTALL_CONTEXT)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND) </span><br><span class="line">          <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don&#x27;t let us unwind past the handler context.  */</span></span><br><span class="line">      <span class="keyword">if</span> (match_handler)</span><br><span class="line">         <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">uw_update_context</span> (context, &amp;fs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上两个函数分别对应了 unwind 过程中的这两个阶段，注意其中的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uw_init_context</span>()</span><br><span class="line"><span class="built_in">uw_frame_state_for</span>()</span><br><span class="line"><span class="built_in">uw_update_context</span>()</span><br></pre></td></tr></table></figure>

<p>这几个函数主要是用来重建函数调用现场的，大概原理是：</p>
<p>对于调用链上的函数来说，它们的很大一部分上下文是可以从堆栈上恢复，如 ebp, esp, 返回地址等</p>
<p>编译器为了让 unwinder 可以从栈上获取这些信息，它的编译代码的时候，<strong>建立了很多表项用于记录每个可以抛异常的函数的相关信息</strong>，这些信息在重建上下文时将指导程序怎么去搜索栈上的东西</p>
<h2 id="Some-interesting-things"><a href="#Some-interesting-things" class="headerlink" title="Some interesting things"></a>Some interesting things</h2><p>说了一大堆，下面写个测试的程序简单回顾一下前面所说的关于异常处理的大概流程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序运行起来后，我们可以在 __gxx_personality_v0 里下一个断点，可以看出流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">2</span>, <span class="number">0x00dd0a46</span> in __gxx_personality_v0 () from /usr/lib/libstdc++.so<span class="number">.6</span></span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00dd0a46</span> in __gxx_personality_v0 () from /usr/lib/libstdc++.so<span class="number">.6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00d2af2c</span> in _Unwind_RaiseException () from /lib/libgcc_s.so<span class="number">.1</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00dd10e2</span> in __cxa_throw () from /usr/lib/libstdc++.so<span class="number">.6</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x08048979</span> <span class="function">in <span class="title">test_func3</span> <span class="params">()</span> at exc.cc:<span class="number">6</span></span></span><br><span class="line"><span class="function">#<span class="number">4</span>  <span class="number">0x080489ac</span> in test_func2 () at exc.cc:<span class="number">16</span></span></span><br><span class="line"><span class="function">#<span class="number">5</span>  <span class="number">0x08048a52</span> in test_func1 () at exc.cc:<span class="number">29</span></span></span><br><span class="line"><span class="function">#<span class="number">6</span>  <span class="number">0x08048ad1</span> in main () at exc.cc:<span class="number">39</span></span></span><br><span class="line"><span class="function">(gdb)</span></span><br></pre></td></tr></table></figure>

<p>（由于基本都不知道，所以基本是对链接文章的注释版复制）</p>
<p>第二篇！</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/3619379.html">https://www.cnblogs.com/catch/p/3619379.html</a></p>
<h1 id="C-异常处理（2）"><a href="#C-异常处理（2）" class="headerlink" title="C++异常处理（2）"></a>C++异常处理（2）</h1><p>前一篇文章简单介绍C++异常处理的流程，但在一些细节 上一带而过</p>
<p>比如</p>
<ul>
<li>_Unwind_RaiseException 是怎样重建函数现场的</li>
<li>Personality routine 是怎样清理栈上变量的</li>
</ul>
<h2 id="相关的数据结构"><a href="#相关的数据结构" class="headerlink" title="相关的数据结构"></a>相关的数据结构</h2><p>unwind 的进行需要<strong>编译器生成一定的数据</strong>来支持，这些数据保存了与每个可能抛异常的函数相关的信息以供运行时查询</p>
<p>那么，编译保存了什么信息？根据 Itanium ABI 的<a target="_blank" rel="noopener" href="http://www.intel.com/content/dam/www/public/us/en/documents/guides/itanium-software-runtime-architecture-guide.pdf">定义</a>，主要包括以下三类：</p>
<ol>
<li>unwind table，这个表记录了与函数相关的信息，共三个字段：函数的起始地址，函数的结束地址，一个 info block 指针</li>
<li>unwind descriptor table，这个列表用于描述函数中需要 unwind 的区域的相关信息</li>
<li>语言相关的数据(language specific data area)，用于上层语言内部的处理</li>
</ol>
<p>以上数据结构的描述来自 Itanium ABI 的标准定义，但在具体实现时，<strong>这些数据是怎么组织以及放到了哪里则是由编译器来决定的</strong></p>
<p>对于 GCC 来说，<strong>所有与 unwind 相关的数据都放到了 .eh_frame 及 .gcc_except_table 这两个 section 里面了</strong>，而且它的格式与内容和标准的定义稍稍有些不同</p>
<h2 id="eh-frame区域"><a href="#eh-frame区域" class="headerlink" title=".eh_frame区域"></a><strong>.eh_frame区域</strong></h2><p>.eh_frame 的格式与 .debug_frame 是很相似的（不完全相同），属于 <a target="_blank" rel="noopener" href="http://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/normativerefs.html#STD.DWARF3">DWARF</a> 标准中的一部分</p>
<p><strong>所有由 GCC 编译生成的需要支持异常处理的程序都包含了 DWARF 格式的数据与字节码</strong></p>
<p>这些数据与字节码的主要作用有两个：</p>
<ol>
<li>描述函数调用栈的结构（layout）</li>
<li>异常发生后，指导 unwinder 怎么进行 unwind</li>
</ol>
<p><strong>DWARF</strong></p>
<p>这个字节码功能很强大，它是图灵完备的，这意味着仅仅通过 DWARF 就可以做任何事情（理论上），由于数据结构较为复杂，这里只记录了与其异常处理相关的staff.</p>
<p><strong>本质上来讲，en_frame 像一张表，它根据程序中的某一条指令来设置相关的寄存器，从而返回到当前函数的调用函数</strong></p>
<p>该表中：</p>
<ul>
<li>CFA（canonical frame address）表示一个基地址，作为当前函数中其他地址的起始地址，使得其他地址可以用该该基地址的偏移地址来表示</li>
<li>由于这个表要覆盖很多程序指令，因此这个表的地址是很大的，甚至比程序的代码量还要大。</li>
<li>而在实际中，为了减少该表的体积，GCC通常会对他进行压缩编码<ul>
<li>比如，<strong>只会对抛异常的函数里的特定区域指令进行记录</strong></li>
</ul>
</li>
</ul>
<p><img src="/C-EXCEPTION-LEARNING/image-20220718142215745.png" alt="image-20220718142215745"></p>
<p>具体的实现上，<strong>en_frame 由一个CIE (Common Information Entry) 及多个 FDE (Frame Description Entry) 组成</strong></p>
<p>它们在内存中是连续存放的：</p>
<p><img src="/C-EXCEPTION-LEARNING/image-20220718143252434.png" alt="image-20220718143252434"></p>
<p>CIE 及 FDE 格式的定义参考如下：</p>
<p><strong>CIE 结构</strong>    </p>
<p><img src="/C-EXCEPTION-LEARNING/image-20220718143415367.png" alt="image-20220718143415367"></p>
<p><strong>FDE结构</strong></p>
<p><img src="/C-EXCEPTION-LEARNING/image-20220718143437431.png" alt="image-20220718143437431"></p>
<p>注意标注红色的字段：</p>
<ol>
<li><p>CIE-&gt;Initial Instructions, FDE-&gt;Call Frame Instructions 这两字段里放的就是所谓的 DWARF 字节码</p>
<ul>
<li>比如：DW_CFA_def_cfa R OFF，表示通过寄存器 R 及位移 OFF 来计算 CFA，其功能类似于前面的表格中第二列指明的内容</li>
</ul>
</li>
<li><p>FDE-&gt;PC begin, PC range, 这两个字段联合起来表示该 <strong>FDE 所能覆盖的指令的范围</strong>, eh_frame 中所有的 FDE 最后会<strong>按照 pc begin 排序</strong>进行存放</p>
</li>
<li><p>如果 CIE 中的 Augmentation String 中包含有字母 “P”，则相应的 Augmentation Data 中包含有指向 <strong>personality routine</strong> 的指针</p>
</li>
<li><p>如果 CIE 中的 Augmentation String 中包含有有字母“L”，则 FDE 中 Aumentation Data 包含有 <strong>language specific data</strong> 的指针</p>
</li>
</ol>
<p>对一个elf文件通过如下命令：readelf -Wwf xxx，可以读取其中关于 .eh_frame 的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The section .eh_frame contains:</span><br><span class="line"></span><br><span class="line">00000000 0000001c 00000000 CIE</span><br><span class="line">  Version:               1</span><br><span class="line">  Augmentation:          &quot;zPL&quot;</span><br><span class="line">  Code alignment factor: 1</span><br><span class="line">  Data alignment factor: -8</span><br><span class="line">  Return address column: 16</span><br><span class="line">  Augmentation data:     00 d8 09 40 00 00 00 00 00 00</span><br><span class="line"></span><br><span class="line">  DW_CFA_def_cfa: r7 ofs 8   ##以下为字节码</span><br><span class="line">  DW_CFA_offset: r16 at cfa-8</span><br><span class="line"></span><br><span class="line">00000020 0000002c 00000024 FDE cie=00000000 pc=00400ac8..00400bd8</span><br><span class="line">  Augmentation data:     00 00 00 00 00 00 00 00</span><br><span class="line">  #以下为字节码</span><br><span class="line">  DW_CFA_advance_loc: 1 to 00400ac9</span><br><span class="line">  DW_CFA_def_cfa_offset: 16</span><br><span class="line">  DW_CFA_offset: r6 at cfa-16</span><br><span class="line">  DW_CFA_advance_loc: 3 to 00400acc</span><br><span class="line">  DW_CFA_def_cfa_reg: r6</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br></pre></td></tr></table></figure>

<p>对于由 GCC 编译出来的程序来说，CIE， FDE 是其在 unwind 过程中恢复现场时所依赖的全部东西，而且是完备的，这里所说的恢复现场指的是恢复调用当前函数的函数的现场</p>
<p>比如，func1 调用 func2，然后我们可以在 func2 里通过<strong>查询 CIE，FDE 恢复 func1 的现场</strong></p>
<p>CIE，FDE 存在于每一个需要处理异常的 ELF 文件中，当异常发生时，runtime 根据当前 PC 值调用 dl_iterate_phdr() 函数就可以把当前程序所加载的所有模块轮询一遍，<strong>从而找到该 PC 所在模块的 eh_frame</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = info-&gt;dlpi_phnum; --n &gt;= <span class="number">0</span>; phdr++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (phdr-&gt;p_type == PT_LOAD)</span><br><span class="line">      &#123;</span><br><span class="line">        _Unwind_Ptr vaddr = phdr-&gt;p_vaddr + load_base;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;pc &gt;= vaddr &amp;&amp; data-&gt;pc &lt; vaddr + phdr-&gt;p_memsz)</span><br><span class="line">          match = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (phdr-&gt;p_type == PT_GNU_EH_FRAME)</span><br><span class="line">        p_eh_frame_hdr = phdr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (phdr-&gt;p_type == PT_DYNAMIC)</span><br><span class="line">        p_dynamic = phdr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>找到 eh_frame 也就找到 CIE，找到了 CIE 也就可以去搜索相应的 FDE，找到FDE及CIE后，就可以从这两数据表中提取相关的信息</p>
<p>并执行DWARF 字节码，从而得到当前函数的调用函数的现场，参看如下用于重建函数帧的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> _Unwind_Reason_Code</span></span><br><span class="line"><span class="function"><span class="title">uw_frame_state_for</span> <span class="params">(struct _Unwind_Context *context, _Unwind_FrameState *fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dwarf_fde</span> *<span class="title">fde</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dwarf_cie</span> *<span class="title">cie</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *aug, *insn, *end;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (fs, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (*fs));</span><br><span class="line">  context-&gt;args_size = <span class="number">0</span>;</span><br><span class="line">  context-&gt;lsda = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据context查找FDE。</span></span><br><span class="line">  fde = _Unwind_Find_FDE (context-&gt;ra - <span class="number">1</span>, &amp;context-&gt;bases);</span><br><span class="line">  <span class="keyword">if</span> (fde == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Couldn&#x27;t find frame unwind info for this function.  Try a</span></span><br><span class="line"><span class="comment">     target-specific fallback mechanism.  This will necessarily</span></span><br><span class="line"><span class="comment">     not provide a personality routine or LSDA.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MD_FALLBACK_FRAME_STATE_FOR</span></span><br><span class="line">      <span class="built_in">MD_FALLBACK_FRAME_STATE_FOR</span> (context, fs, success);</span><br><span class="line">      <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line">    success:</span><br><span class="line">      <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fs-&gt;pc = context-&gt;bases.func;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应的CIE.</span></span><br><span class="line">  cie = <span class="built_in">get_cie</span> (fde);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取出CIE中的信息，如personality routine的地址。</span></span><br><span class="line">  insn = <span class="built_in">extract_cie_info</span> (cie, context, fs);</span><br><span class="line">  <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* CIE contained unknown augmentation.  */</span></span><br><span class="line">    <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First decode all the insns in the CIE.  */</span></span><br><span class="line">  end = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) <span class="built_in">next_fde</span> ((struct dwarf_fde *) cie);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行dwarf字节码，从而恢复相应的寄存器的值。</span></span><br><span class="line">  <span class="built_in">execute_cfa_program</span> (insn, end, context, fs);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定位到fde的相关数据</span></span><br><span class="line">  <span class="comment">/* Locate augmentation for the fde.  */</span></span><br><span class="line">  aug = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fde + <span class="built_in"><span class="keyword">sizeof</span></span> (*fde);</span><br><span class="line">  aug += <span class="number">2</span> * <span class="built_in">size_of_encoded_value</span> (fs-&gt;fde_encoding);</span><br><span class="line">  insn = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (fs-&gt;saw_z)</span><br><span class="line">    &#123;</span><br><span class="line">      _Unwind_Word i;</span><br><span class="line">      aug = <span class="built_in">read_uleb128</span> (aug, &amp;i);</span><br><span class="line">      insn = aug + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取language specific data的指针</span></span><br><span class="line">  <span class="keyword">if</span> (fs-&gt;lsda_encoding != DW_EH_PE_omit)</span><br><span class="line">    aug = <span class="built_in">read_encoded_value</span> (context, fs-&gt;lsda_encoding, aug,</span><br><span class="line">                  (_Unwind_Ptr *) &amp;context-&gt;lsda);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then the insns in the FDE up to our target PC.  */</span></span><br><span class="line">  <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">    insn = aug;</span><br><span class="line">  end = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) <span class="built_in">next_fde</span> (fde);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行FDE中的字节码。</span></span><br><span class="line">  <span class="built_in">execute_cfa_program</span> (insn, end, context, fs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过如上的操作，unwinder 就已经把调用函数的现场给重建起来了，这些现场信息包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *reg[DWARF_FRAME_REGISTERS+<span class="number">1</span>];  <span class="comment">//必要的寄存器。</span></span><br><span class="line">    <span class="keyword">void</span> *cfa; <span class="comment">// canoniacl frame address, 前面提到过，基地址。</span></span><br><span class="line">    <span class="keyword">void</span> *ra;<span class="comment">// 返回地址。</span></span><br><span class="line">    <span class="keyword">void</span> *lsda;<span class="comment">// 该函数对应的language specific data,如果存在的话。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dwarf_eh_bases</span> <span class="title">bases</span>;</span></span><br><span class="line">  _Unwind_Word args_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="实现-Personality-routine"><a href="#实现-Personality-routine" class="headerlink" title="实现 Personality routine"></a>实现 Personality routine</h3><p>Peronality routine 的作用主要有两个：</p>
<ol>
<li><p>检查当前函数是否有相应的 catch 语句。</p>
</li>
<li><p>清理当前函数中的局部变量</p>
</li>
</ol>
<p>然而这两件事情仅仅依靠 <strong>运行时</strong> 也是没法完成的，必须依靠编译器在 <strong>编译时</strong> 建立起相关的数据进行协助</p>
<p>对于GCC来说，这些与抛异常的函数具体相关的信息全部放在 .gcc_except_table 区域里去了，这些信息会作为Itanium ABI 接口中所谓的 language specific data 在 unwinder 与 C++ ABI 之间传递</p>
<p>根据前面的介绍，<strong>我们知道在 FDE 中保存有指向 language specific data 的指针</strong>（前面的源码中），因此 unwinder 在重建现场的时候就已经把这些数据读取了出来，c++ 的 ABI 只要调用 _Unwind_GetLanguageSpecificData() 就可以得到指向该数据的指针</p>
<p>下图来源于网络，展示了gcc_except_table 及 language specific data 的格式：</p>
<p><img src="/C-EXCEPTION-LEARNING/image-20220718155130981.png" alt="image-20220718155130981"></p>
<p>由上图所示，LSDA 由一个表头以及三个表组成</p>
<h4 id="1-LSDA-Header："><a href="#1-LSDA-Header：" class="headerlink" title="1.LSDA Header："></a>1.LSDA Header：</h4><p><strong>该表头主要用来保存接下来三张表的相关信息，如编码，及表的位移等</strong>，该表头主要包含六个域：</p>
<p>1）LPStart encoding: Landing pad 起始地址的编码方式，长度为一个字节。</p>
<p>2）LPStart: landing pad 起始地址，这是可选的，只有当前面指明的编码方式不等于 DW_EH_PE_omit 时，这个字段才存在，此时读取这个字段就需要根据前面指定的编码方式进行读取，长度不固定，如果这个字段不存在，则 landing pad 的起始地址需要通过调用 _Unwind_GetRegionStart() 来获得，得到其实就是当前模块加载的起始地址，这是最常见的形式。</p>
<p>3）TType format: type table 的编码方式，长度为一个字节。</p>
<p>4）TTBase: type table 的位移，类型为 unsigned LEB128，这个字段是可选的，只有3）中编码方式不等于 DW_EH_PE_omit 时，这个才存在。</p>
<p>5）Call Site format: call site table 的编码方式，长度为一个字节。</p>
<p>6）Call Site format size: call site table 的长度，一个 unsigned LEB128 的值。</p>
<p>（不经想起第一次学PE文件数据结构的时候，一堆名词打在脸上，这次显然比上次的接受度高多了）</p>
<h4 id="2-call-site-table"><a href="#2-call-site-table" class="headerlink" title="2.call site table"></a>2.call site table</h4><p>LSDA 表头之后紧跟着的是 call site table，<strong>该表用于记录程序中哪些指令有可能会抛异常，表中每条记录共有4个字段</strong>：</p>
<p>1）call site position: 可能会抛异常的指令的地址，该地址是距 Landing pad 起始地址的偏移，编码方式由 LSDA 表头中第一个字段指明。</p>
<p>2）call the length: 可能抛异常的指令的区域长度，该字段与 1）一起表示一系列连续的指令，编码方式与 1）相同。</p>
<p>3）landing pad position: 用于处理上述指令的 Landing pad 的位移，这个值如果为 0 则表示不存在相应的 landing pad。</p>
<p>4）first action: 指明要采取哪些 action，这是一个 unsigned LEB128 的值，该值减1后作为下标获取 action table 中相应记录。</p>
<p>PS: <strong>call site table 中的记录按第一个字段也就是指令起始地址进行排序存放，因此 unwind 的时候可以加快对该表的搜索</strong></p>
<p>unwind 的过程中:</p>
<ul>
<li><p>如果当前 pc 的值不在 call site table 覆盖的范围内的话，搜索就会返回，然后就调用std::terminate() 结束程序，这通常来说是不正常的行为</p>
</li>
<li><p>如果在 call site table 中有对应的处理，但 landing pad 的位移却是 0 的话，表明当前函数既不存在 catch 语句，也不需要清理局部变量，这是一种正常情况，unwinder 应该继续向上 unwind</p>
</li>
<li><p>而如果 landing pad 不为0，则表明该函数中有 catch 语句，但是这些 catch 能否处理抛出的异常则还要结合 action 字段，到 type table 中去进一步加以判断</p>
<ul>
<li>如果 action 字段为 0，则表明当前函数没有 catch 语句，但有局部变量需要清理</li>
<li>如果 action 字段不为 0，则表明当前函数中存在 catch 语句，<strong>又因为 catch 是可能存在多个的</strong>，怎么知道哪个能够 catch 当前的异常呢？因此需要去<strong>检查 action table 中的表项</strong></li>
</ul>
</li>
</ul>
<p>(这里应该就是指向ttypeindex的关键了)</p>
<h4 id="3-Action-table"><a href="#3-Action-table" class="headerlink" title="3. Action table"></a>3. Action table</h4><p>action table 中每一条记录是一个二元组</p>
<p><strong>表示一个 catch 语句所对应的异常，或者表示当前函数所允许抛出的异常 (exception specification)，该列表每条记录包含两个字段</strong>：</p>
<p>1）type filter: 这是一个 unsigned LEB128 的数值，用于指向 type table 中的记录，该值有可能是负数。（这就是Inflated题中的ttypeindex?）</p>
<p>2）offset to next action: 指向下一个 action table 中的下一条记录，这是当函数中有多个 catch 或 exception specification 有多个时，将各个 action 记录链接起来。</p>
<h4 id="4-Type-Table"><a href="#4-Type-Table" class="headerlink" title="4. Type Table"></a>4. Type Table</h4><p>type table 中存放的是异常类型的指针:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::type_info* type_tables[];</span><br></pre></td></tr></table></figure>

<p>这个表被分成两部分，一部分是各个 catch 所对应的异常的类型，另一部分是该函数允许抛出的异常类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func() throw(int, string)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type table中这两部分分别通过正负下标来进行索引：</p>
<p><img src="/C-EXCEPTION-LEARNING/070326314977733.jpg" alt="img"></p>
<p><strong>有了如上这些数据，personality routine 只需要根据当前的 pc 值及当前的异常类型，不断在上述表中查找</strong></p>
<p><strong>最后就能找到当前函数是否有 landing pad，如果有则返回 _URC_INSTALL_CONTEXT，指示 unwinder 跳过去执行相应的代码。</strong></p>
<h2 id="什么是-Landing-pad"><a href="#什么是-Landing-pad" class="headerlink" title="什么是 Landing pad"></a>什么是 Landing pad</h2><p>在前面一篇博文里，提到了Landing pad：指的是能够 catch 当前异常的 catch 语句。这个说法其实不确切，准确来说，landing pad 指的是 unwinder 之外的“用户代码”：</p>
<p>1）用于 catch 相应的 exception，对于一个函数来说，如果该函数中有 catch 语句，且能够处理当前的异常，则该 catch 就是 landing pad。</p>
<p>2）如果当前函数没有 catch 或者 catch 不能处理当前 exception，则意味着异常还要从当前函数继续往上抛，因而 unwind 当前函数时有可能要进行相应的清理，<strong>此时这些清理局部变量的代码就是 landing pad</strong>。</p>
<p>从名字上来看，顾名思议，<strong>landing pad 指的是程序的执行流程在进入当前函数后，最后要转到这里去</strong>（可以是用户写的catch代码也可以是清理局部变量的代码），很恰当的描述。</p>
<p>当 landing pad 是 catch 语句时，这个比较好理解，前面我们一直说清理局部变量的代码，这是什么意思呢？这些清理代码又放在哪里？为了说明这个问题，我们看一下如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">cs</span><span class="params">(<span class="keyword">int</span> i)</span> :i_(i) &#123;</span> cout &lt;&lt; <span class="string">&quot;cs constructor:&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">        ~<span class="built_in">cs</span>() &#123; cout &lt;&lt; <span class="string">&quot;cs destructor:&quot;</span> &lt;&lt; i_ &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cs <span class="title">c</span><span class="params">(<span class="number">33</span>)</span></span>;</span><br><span class="line">    <span class="function">cs <span class="title">c2</span><span class="params">(<span class="number">332</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">cs <span class="title">c3</span><span class="params">(<span class="number">333</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func3_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意这</span></span><br><span class="line">    <span class="function">cs <span class="title">c</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">cs <span class="title">c2</span><span class="params">(<span class="number">322</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">cs <span class="title">c3</span><span class="params">(<span class="number">323</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test_func3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cs <span class="title">c</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func3_2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">cs <span class="title">c2</span><span class="params">(<span class="number">222</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">test_func2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_func1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数 test_func3_2() 来说，当 test_func3() 抛出异常后，在 unwind 的第二阶段，我们知道 test_func3_2() 中的局部变量 c 及 c2 是需要清理的，而 c3 则不用，那么编译器是怎么生成代码来完成这件事情的呢？</p>
<p><strong>当异常发生时，运行时是没有办法知道当前哪些变量是需要清理的</strong>，因为这个原因<strong>编译器</strong>在生成代码的时候，在函数的末尾设置了多个出口，使得当异常发生时，可以直接跳到某一段代码就能清理相应的局部变量，我们看看 test_func3_2() 编译后生成的对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void test_func3_2()</span><br><span class="line">&#123;</span><br><span class="line">  400ca4:    55                     push   %rbp</span><br><span class="line">  400ca5:    48 89 e5               mov    %rsp,%rbp</span><br><span class="line">  400ca8:    53                     push   %rbx</span><br><span class="line">  400ca9:    48 83 ec 48            sub    $0x48,%rsp</span><br><span class="line">    cs c(32);</span><br><span class="line">  400cad:    48 8d 7d e0            lea    0xffffffffffffffe0(%rbp),%rdi</span><br><span class="line">  400cb1:    be 20 00 00 00         mov    $0x20,%esi</span><br><span class="line">  400cb6:    e8 9f 02 00 00         callq  400f5a &lt;_ZN2csC1Ei&gt;</span><br><span class="line">    cs c2(322);</span><br><span class="line">  400cbb:    48 8d 7d d0            lea    0xffffffffffffffd0(%rbp),%rdi</span><br><span class="line">  400cbf:    be 42 01 00 00         mov    $0x142,%esi</span><br><span class="line">  400cc4:    e8 91 02 00 00         callq  400f5a &lt;_ZN2csC1Ei&gt;</span><br><span class="line"></span><br><span class="line">    test_func3();</span><br><span class="line">  400cc9:    e8 5a ff ff ff         callq  400c28 &lt;_Z10test_func3v&gt;</span><br><span class="line"></span><br><span class="line">    cs c3(323);</span><br><span class="line">  400cce:    48 8d 7d c0            lea    0xffffffffffffffc0(%rbp),%rdi</span><br><span class="line">  400cd2:    be 43 01 00 00         mov    $0x143,%esi</span><br><span class="line">  400cd7:    e8 7e 02 00 00         callq  400f5a &lt;_ZN2csC1Ei&gt;</span><br><span class="line"></span><br><span class="line">    test_func3();</span><br><span class="line">  400cdc:    e8 47 ff ff ff         callq  400c28 &lt;_Z10test_func3v&gt;</span><br><span class="line">  400ce1:    eb 17                  jmp    400cfa &lt;_Z12test_func3_2v+0x56&gt;</span><br><span class="line">  400ce3:    48 89 45 b8            mov    %rax,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400ce7:    48 8b 5d b8            mov    0xffffffffffffffb8(%rbp),%rbx</span><br><span class="line">  400ceb:    48 8d 7d c0            lea    0xffffffffffffffc0(%rbp),%rdi #c3的this指针</span><br><span class="line">  400cef:    e8 2e 02 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">  400cf4:    48 89 5d b8            mov    %rbx,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400cf8:    eb 0f                  jmp    400d09 &lt;_Z12test_func3_2v+0x65&gt;</span><br><span class="line">  400cfa:    48 8d 7d c0            lea    0xffffffffffffffc0(%rbp),%rdi #c3的this指针</span><br><span class="line">  400cfe:    e8 1f 02 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">  400d03:    eb 17                  jmp    400d1c &lt;_Z12test_func3_2v+0x78&gt;</span><br><span class="line">  400d05:    48 89 45 b8            mov    %rax,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400d09:    48 8b 5d b8            mov    0xffffffffffffffb8(%rbp),%rbx</span><br><span class="line">  400d0d:    48 8d 7d d0            lea    0xffffffffffffffd0(%rbp),%rdi #c2的this指针</span><br><span class="line">  400d11:    e8 0c 02 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">  400d16:    48 89 5d b8            mov    %rbx,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400d1a:    eb 0f                  jmp    400d2b &lt;_Z12test_func3_2v+0x87&gt; </span><br><span class="line">  400d1c:    48 8d 7d d0            lea    0xffffffffffffffd0(%rbp),%rdi #c2的this指针</span><br><span class="line">  400d20:    e8 fd 01 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">  400d25:    eb 1e                  jmp    400d45 &lt;_Z12test_func3_2v+0xa1&gt;</span><br><span class="line">  400d27:    48 89 45 b8            mov    %rax,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400d2b:    48 8b 5d b8            mov    0xffffffffffffffb8(%rbp),%rbx</span><br><span class="line">  400d2f:    48 8d 7d e0            lea    0xffffffffffffffe0(%rbp),%rdi #c的this指针</span><br><span class="line">  400d33:    e8 ea 01 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">  400d38:    48 89 5d b8            mov    %rbx,0xffffffffffffffb8(%rbp)</span><br><span class="line">  400d3c:    48 8b 7d b8            mov    0xffffffffffffffb8(%rbp),%rdi</span><br><span class="line">  400d40:    e8 b3 fc ff ff         callq  4009f8 &lt;_Unwind_Resume@plt&gt;  #c的this指针</span><br><span class="line">  400d45:    48 8d 7d e0            lea    0xffffffffffffffe0(%rbp),%rdi</span><br><span class="line">  400d49:    e8 d4 01 00 00         callq  400f22 &lt;_ZN2csD1Ev&gt;</span><br><span class="line">&#125;</span><br><span class="line">  400d4e:    48 83 c4 48            add    $0x48,%rsp</span><br><span class="line">  400d52:    5b                     pop    %rbx</span><br><span class="line">  400d53:    c9                     leaveq </span><br><span class="line">  400d54:    c3                     retq   </span><br><span class="line">  400d55:    90                     nop</span><br></pre></td></tr></table></figure>

<p>注意其中标红色的代码，_<strong>ZN2csD1Ev 即是类 cs 的析构函数</strong></p>
<p>Unwind_Resume() 则是当清理完成时，用来从 landing pad 返回的代码</p>
<p>test_func3_2() 中只有 3 个 cs 对象，但调用析构函数的代码却出现了 6 次。这里其实就是设置了多个出口函数，分别对应不同情况下，处理各个局部变量的析构，对于我们上面的代码来说，test_func3_2() 函数中的 landing pad 就是从地址：400d09 开始的，这些代码做了如下事情：</p>
<p>1）先析构 c2，然后 jump 到 400d2b 析构 c.</p>
<p>2）最后调用 _Unwind_Resum()</p>
<p>由此可见当程序中有多个可能抛异常的地方时，landing pad 也相应地会有多个，该函数的出口将更复杂，这也算是异常处理的一个 overhead 了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>太强了，实在是太强了，我感觉很久没看过这么干货满满的文章，感觉是我异常处理认识的一个升华，不过新名词太多，也需要反复阅读理解方可行</p>

    </div>

    <p style= "text-align:center">
        让我看看我被读了 
    <b><span id="/2022/07/18/C-EXCEPTION-LEARNING/" class="waline-visitor-count"/>...</b> 次呢🎉</p>
    
    <div id = "frozen-btn" class = "center">
    <!-- <button class="green" onclick = "Change()">🎉☕一杯咖啡~</button> -->
    <button class="purple" onclick = "Change()">🍰</button>
    </div>
    
    <div class = "hide" id = "img">
        <div class="post-list">
            <article class="post-list-item">
                <div class="content">
                    <img src="/img/Coffee/AliPay.png" alt="DASCTF X SU">
                    <div class="center">
                        🍬
                    </div>
                </div>
            </article>
            <article class="post-list-item">
                <div class="content">
                    <img src="/img/Coffee/WeChat.png" alt="HFCTF2022">
                    <div class="center">
                        🍪
                    </div>
                </div>
            </article>
        </div>
    </div>
    <script>
            function Change()
            {
                var img = document.getElementById("img");
                if(img.className == "hide")
                {
                    img.className="";
                }
                else
                {
                    img.className="hide";
                }
            }
    </script>

    <div class="about">
        <h1>About this Post</h1>
        <p>This post is written by P.Z, licensed under <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>
    <!-- 
        
     -->
<div class="container">
<!-- <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
      serverURL: 'https://blog-api-pozeep.vercel.app/',  
      visitor: true,
      emoji: [   //这里加了一些表情 
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq',
        'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
      ],
       avatar: 'robohash',   //自定义默认头像为随机的机器人
       placeholder: '🍟🍰🧊🍔🍓🍫🍦🍗🍇🍉🍑🥐🍕',   //占位符
    });
  </script>
</div> -->

<!-- <span id="/2022/07/18/C-EXCEPTION-LEARNING/" class="leancloud_visitors" data-flag-title="C++ EXCEPTION LEARNING">
    <em class="post-meta-item-text">阅读量 </em>
    <i class="waline-visitor-count"></i>
</span> -->

</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Home</a>
                
                <a href="/Diary/Diary.html" class="item">Diary</a>
                
                <a href="/Friends/Friends.html" class="item">Friends</a>
                
                <a href="/CTF/CTF.html" class="item">CTF</a>
                
                <a href="/Book/Book.html" class="item">Book</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/PoZeep" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/39892350" class="item">BiliBili</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 P.Z<br >Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></span>
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
        
    <span id="sitetime" style="text-align: center;display:block;"></span>


</footer>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 12, 27, 12, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "我已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了*/
    siteTime();
</script>

<!-- 在线通讯Tidio -->

<script src="//code.tidio.co/zmdcv08a6racnaer2so7xybdwby41fsa.js"></script>



        
<script src="/js/main.js"></script>

        
    </body>
</html>